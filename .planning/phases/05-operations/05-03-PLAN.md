---
phase: 05-operations
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/actions/dashboard.ts
  - src/app/(dashboard)/dashboard/page.tsx
  - src/app/(admin)/admin/page.tsx
  - src/components/dashboard/dashboard-stats.tsx
  - src/components/dashboard/calculations-table.tsx
  - src/components/dashboard/org-list.tsx
autonomous: true

must_haves:
  truths:
    - "Super Admin sees all organizations with calculation counts"
    - "Super Admin sees all calculations filterable by org, closer, date"
    - "Org Admin sees their org's calculations"
    - "Closer sees their own calculations with view counts"
    - "Dashboard shows link analytics (views, last viewed)"
  artifacts:
    - path: "src/actions/dashboard.ts"
      provides: "Role-based dashboard data fetching"
      exports: ["getDashboardStats", "getCalculationsForDashboard", "getOrganizationsWithStats"]
    - path: "src/app/(dashboard)/dashboard/page.tsx"
      provides: "Closer/Org Admin dashboard view"
      contains: "DashboardStats"
    - path: "src/app/(admin)/admin/page.tsx"
      provides: "Super Admin dashboard view"
      contains: "OrgList"
    - path: "src/components/dashboard/calculations-table.tsx"
      provides: "Filterable calculations table"
      exports: ["CalculationsTable"]
  key_links:
    - from: "src/app/(dashboard)/dashboard/page.tsx"
      to: "src/actions/dashboard.ts"
      via: "getDashboardStats call"
      pattern: "getDashboardStats"
    - from: "src/components/dashboard/calculations-table.tsx"
      to: "link analytics fields"
      via: "viewCount and lastViewedAt display"
      pattern: "viewCount|lastViewedAt"
---

<objective>
Create role-based admin dashboards showing organization and calculation statistics with link analytics.

Purpose: Give each role appropriate visibility into their calculations and engagement metrics.

Output:
- Dashboard actions with role-based data scoping
- Super Admin view: all orgs with calculation counts, all calculations filterable
- Org Admin view: org's calculations with stats
- Closer view: own calculations with view counts and last viewed
- Link analytics (views, last viewed) displayed for shared calculations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-operations/05-RESEARCH.md

Key patterns from research:
- Role-based queries: SUPER_ADMIN sees all, ORG_ADMIN sees org, CLOSER sees own
- Use existing tenant scoping pattern with createTenantClient
- Show view counts from CalculationView._count
- Show last viewed from CalculationView aggregate max(viewedAt)

Existing patterns:
- listCalculations already shows viewCount in list
- Calculations have _count: { views: true } pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard server actions</name>
  <files>src/actions/dashboard.ts</files>
  <action>
Create dashboard data fetching actions with role-based scoping:

```typescript
// src/actions/dashboard.ts
'use server'

import { auth } from '@/lib/auth/auth'
import { prisma } from '@/lib/db/client'
import { createTenantClient } from '@/lib/db/tenant-client'
import { hasPermission, PERMISSIONS, type Role } from '@/lib/auth/permissions'

// =============================================================================
// TYPES
// =============================================================================

export interface DashboardStats {
  totalCalculations: number
  totalViews: number
  recentCalculations: {
    id: string
    customerName: string
    status: string
    createdAt: Date
    updatedAt: Date
    viewCount: number
    lastViewedAt: Date | null
    shareCode: string | null
    batteryName: string | null
    closerName?: string
    orgName?: string
  }[]
}

export interface OrgStats {
  id: string
  name: string
  slug: string
  isProffsKontaktAffiliated: boolean
  calculationCount: number
  userCount: number
  totalViews: number
}

export interface CalculationForDashboard {
  id: string
  customerName: string
  status: string
  elomrade: string
  createdAt: Date
  updatedAt: Date
  finalizedAt: Date | null
  viewCount: number
  lastViewedAt: Date | null
  shareCode: string | null
  shareIsActive: boolean
  batteryName: string | null
  closerName: string
  closerEmail: string
  orgName: string
  orgSlug: string
}

// =============================================================================
// GET DASHBOARD STATS
// =============================================================================

/**
 * Get dashboard statistics for the current user.
 *
 * - Super Admin: aggregate across all orgs
 * - Org Admin: aggregate for their org
 * - Closer: aggregate for their own calculations
 */
export async function getDashboardStats(): Promise<{ data?: DashboardStats; error?: string }> {
  const session = await auth()
  if (!session?.user) return { error: 'Unauthorized' }

  const role = session.user.role as Role

  try {
    if (role === 'SUPER_ADMIN') {
      // All calculations across all orgs
      const [totalCalcs, totalViews, recent] = await Promise.all([
        prisma.calculation.count({ where: { status: { not: 'ARCHIVED' } } }),
        prisma.calculationView.count(),
        prisma.calculation.findMany({
          where: { status: { not: 'ARCHIVED' } },
          orderBy: { updatedAt: 'desc' },
          take: 10,
          include: {
            _count: { select: { views: true } },
            batteries: {
              include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
              orderBy: { sortOrder: 'asc' },
              take: 1,
            },
            organization: { select: { name: true } },
          },
        }),
      ])

      // Get last viewed for each recent calc
      const recentWithLastViewed = await Promise.all(
        recent.map(async (c) => {
          const lastView = await prisma.calculationView.findFirst({
            where: { calculationId: c.id },
            orderBy: { viewedAt: 'desc' },
            select: { viewedAt: true },
          })
          return {
            id: c.id,
            customerName: c.customerName,
            status: c.status,
            createdAt: c.createdAt,
            updatedAt: c.updatedAt,
            viewCount: c._count.views,
            lastViewedAt: lastView?.viewedAt || null,
            shareCode: c.shareCode,
            batteryName: c.batteries[0]
              ? `${c.batteries[0].batteryConfig.brand.name} ${c.batteries[0].batteryConfig.name}`
              : null,
            orgName: c.organization.name,
          }
        })
      )

      return {
        data: {
          totalCalculations: totalCalcs,
          totalViews,
          recentCalculations: recentWithLastViewed,
        },
      }
    } else if (role === 'ORG_ADMIN') {
      // Org's calculations
      const tenantClient = createTenantClient(session.user.orgId!)
      const [totalCalcs, recent] = await Promise.all([
        tenantClient.calculation.count({ where: { status: { not: 'ARCHIVED' } } }),
        tenantClient.calculation.findMany({
          where: { status: { not: 'ARCHIVED' } },
          orderBy: { updatedAt: 'desc' },
          take: 10,
          include: {
            _count: { select: { views: true } },
            batteries: {
              include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
              orderBy: { sortOrder: 'asc' },
              take: 1,
            },
          },
        }),
      ])

      // Get total views for org
      const totalViews = await prisma.calculationView.count({
        where: { calculation: { orgId: session.user.orgId! } },
      })

      // Get last viewed and closer name for each recent calc
      const recentWithDetails = await Promise.all(
        recent.map(async (c) => {
          const [lastView, closer] = await Promise.all([
            prisma.calculationView.findFirst({
              where: { calculationId: c.id },
              orderBy: { viewedAt: 'desc' },
              select: { viewedAt: true },
            }),
            prisma.user.findUnique({
              where: { id: c.createdBy },
              select: { name: true },
            }),
          ])
          return {
            id: c.id,
            customerName: c.customerName,
            status: c.status,
            createdAt: c.createdAt,
            updatedAt: c.updatedAt,
            viewCount: c._count.views,
            lastViewedAt: lastView?.viewedAt || null,
            shareCode: c.shareCode,
            batteryName: c.batteries[0]
              ? `${c.batteries[0].batteryConfig.brand.name} ${c.batteries[0].batteryConfig.name}`
              : null,
            closerName: closer?.name,
          }
        })
      )

      return {
        data: {
          totalCalculations: totalCalcs,
          totalViews,
          recentCalculations: recentWithDetails,
        },
      }
    } else {
      // CLOSER - own calculations only
      const tenantClient = createTenantClient(session.user.orgId!)
      const [totalCalcs, recent] = await Promise.all([
        tenantClient.calculation.count({
          where: { createdBy: session.user.id, status: { not: 'ARCHIVED' } },
        }),
        tenantClient.calculation.findMany({
          where: { createdBy: session.user.id, status: { not: 'ARCHIVED' } },
          orderBy: { updatedAt: 'desc' },
          take: 10,
          include: {
            _count: { select: { views: true } },
            batteries: {
              include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
              orderBy: { sortOrder: 'asc' },
              take: 1,
            },
          },
        }),
      ])

      // Get total views for user's calculations
      const calcIds = recent.map((c) => c.id)
      const totalViews = await prisma.calculationView.count({
        where: { calculationId: { in: calcIds } },
      })

      // Get last viewed for each recent calc
      const recentWithLastViewed = await Promise.all(
        recent.map(async (c) => {
          const lastView = await prisma.calculationView.findFirst({
            where: { calculationId: c.id },
            orderBy: { viewedAt: 'desc' },
            select: { viewedAt: true },
          })
          return {
            id: c.id,
            customerName: c.customerName,
            status: c.status,
            createdAt: c.createdAt,
            updatedAt: c.updatedAt,
            viewCount: c._count.views,
            lastViewedAt: lastView?.viewedAt || null,
            shareCode: c.shareCode,
            batteryName: c.batteries[0]
              ? `${c.batteries[0].batteryConfig.brand.name} ${c.batteries[0].batteryConfig.name}`
              : null,
          }
        })
      )

      return {
        data: {
          totalCalculations: totalCalcs,
          totalViews,
          recentCalculations: recentWithLastViewed,
        },
      }
    }
  } catch (error) {
    console.error('Dashboard stats error:', error)
    return { error: 'Kunde inte hamta statistik' }
  }
}

// =============================================================================
// GET ORGANIZATIONS WITH STATS (Super Admin only)
// =============================================================================

/**
 * Get all organizations with calculation counts.
 *
 * Super Admin only.
 */
export async function getOrganizationsWithStats(): Promise<{ data?: OrgStats[]; error?: string }> {
  const session = await auth()
  if (!session?.user) return { error: 'Unauthorized' }

  const role = session.user.role as Role
  if (!hasPermission(role, PERMISSIONS.ORG_VIEW_ALL)) {
    return { error: 'Forbidden' }
  }

  try {
    const orgs = await prisma.organization.findMany({
      orderBy: { name: 'asc' },
      include: {
        _count: {
          select: {
            calculations: { where: { status: { not: 'ARCHIVED' } } },
            users: { where: { isActive: true } },
          },
        },
      },
    })

    // Get total views per org
    const orgsWithViews = await Promise.all(
      orgs.map(async (org) => {
        const totalViews = await prisma.calculationView.count({
          where: { calculation: { orgId: org.id } },
        })
        return {
          id: org.id,
          name: org.name,
          slug: org.slug,
          isProffsKontaktAffiliated: org.isProffsKontaktAffiliated,
          calculationCount: org._count.calculations,
          userCount: org._count.users,
          totalViews,
        }
      })
    )

    return { data: orgsWithViews }
  } catch (error) {
    console.error('Get orgs error:', error)
    return { error: 'Kunde inte hamta organisationer' }
  }
}

// =============================================================================
// GET CALCULATIONS FOR DASHBOARD (Super Admin - filterable)
// =============================================================================

export interface CalculationsFilter {
  orgId?: string
  closerId?: string
  dateFrom?: string
  dateTo?: string
}

/**
 * Get all calculations with filters.
 *
 * Super Admin only - can filter by org, closer, date range.
 */
export async function getCalculationsForDashboard(
  filters: CalculationsFilter = {}
): Promise<{ data?: CalculationForDashboard[]; error?: string }> {
  const session = await auth()
  if (!session?.user) return { error: 'Unauthorized' }

  const role = session.user.role as Role
  if (!hasPermission(role, PERMISSIONS.CALCULATION_VIEW_ALL)) {
    return { error: 'Forbidden' }
  }

  try {
    const where: Record<string, unknown> = {
      status: { not: 'ARCHIVED' },
    }

    if (filters.orgId) {
      where.orgId = filters.orgId
    }
    if (filters.closerId) {
      where.createdBy = filters.closerId
    }
    if (filters.dateFrom || filters.dateTo) {
      where.createdAt = {}
      if (filters.dateFrom) {
        (where.createdAt as Record<string, Date>).gte = new Date(filters.dateFrom)
      }
      if (filters.dateTo) {
        (where.createdAt as Record<string, Date>).lte = new Date(filters.dateTo)
      }
    }

    const calculations = await prisma.calculation.findMany({
      where,
      orderBy: { updatedAt: 'desc' },
      take: 100,
      include: {
        _count: { select: { views: true } },
        batteries: {
          include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
          orderBy: { sortOrder: 'asc' },
          take: 1,
        },
        organization: { select: { name: true, slug: true } },
      },
    })

    // Get closer info and last viewed for each
    const calcsWithDetails = await Promise.all(
      calculations.map(async (c) => {
        const [closer, lastView] = await Promise.all([
          prisma.user.findUnique({
            where: { id: c.createdBy },
            select: { name: true, email: true },
          }),
          prisma.calculationView.findFirst({
            where: { calculationId: c.id },
            orderBy: { viewedAt: 'desc' },
            select: { viewedAt: true },
          }),
        ])
        return {
          id: c.id,
          customerName: c.customerName,
          status: c.status,
          elomrade: c.elomrade,
          createdAt: c.createdAt,
          updatedAt: c.updatedAt,
          finalizedAt: c.finalizedAt,
          viewCount: c._count.views,
          lastViewedAt: lastView?.viewedAt || null,
          shareCode: c.shareCode,
          shareIsActive: c.shareIsActive,
          batteryName: c.batteries[0]
            ? `${c.batteries[0].batteryConfig.brand.name} ${c.batteries[0].batteryConfig.name}`
            : null,
          closerName: closer?.name || 'Okand',
          closerEmail: closer?.email || '',
          orgName: c.organization.name,
          orgSlug: c.organization.slug,
        }
      })
    )

    return { data: calcsWithDetails }
  } catch (error) {
    console.error('Get calculations error:', error)
    return { error: 'Kunde inte hamta kalkyler' }
  }
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Dashboard server actions created with role-based data scoping and link analytics
  </done>
</task>

<task type="auto">
  <name>Task 2: Create dashboard UI components</name>
  <files>
    src/components/dashboard/dashboard-stats.tsx
    src/components/dashboard/calculations-table.tsx
    src/components/dashboard/org-list.tsx
  </files>
  <action>
**src/components/dashboard/dashboard-stats.tsx:**
```typescript
import type { DashboardStats } from '@/actions/dashboard'
import Link from 'next/link'
import { formatDistanceToNow } from 'date-fns'
import { sv } from 'date-fns/locale'

interface Props {
  stats: DashboardStats
  showOrg?: boolean
  showCloser?: boolean
}

export function DashboardStatsView({ stats, showOrg, showCloser }: Props) {
  return (
    <div className="space-y-6">
      {/* Summary cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <p className="text-sm text-gray-500 dark:text-gray-400">Totalt kalkyler</p>
          <p className="text-3xl font-bold text-gray-900 dark:text-white">{stats.totalCalculations}</p>
        </div>
        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-gray-200 dark:border-gray-700">
          <p className="text-sm text-gray-500 dark:text-gray-400">Totalt visningar</p>
          <p className="text-3xl font-bold text-gray-900 dark:text-white">{stats.totalViews}</p>
        </div>
      </div>

      {/* Recent calculations */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Senaste kalkyler</h2>
        </div>
        <div className="divide-y divide-gray-200 dark:divide-gray-700">
          {stats.recentCalculations.length === 0 ? (
            <p className="px-6 py-4 text-sm text-gray-500 dark:text-gray-400">Inga kalkyler annu</p>
          ) : (
            stats.recentCalculations.map((calc) => (
              <Link
                key={calc.id}
                href={`/dashboard/calculations/${calc.id}`}
                className="block px-6 py-4 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors"
              >
                <div className="flex items-center justify-between">
                  <div>
                    <p className="font-medium text-gray-900 dark:text-white">{calc.customerName}</p>
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      {calc.batteryName || 'Inget batteri valt'}
                      {showOrg && calc.orgName && ` • ${calc.orgName}`}
                      {showCloser && calc.closerName && ` • ${calc.closerName}`}
                    </p>
                  </div>
                  <div className="text-right">
                    {calc.shareCode ? (
                      <div className="flex items-center gap-2 text-sm">
                        <span className="text-blue-600 dark:text-blue-400">{calc.viewCount} visningar</span>
                        {calc.lastViewedAt && (
                          <span className="text-gray-400">
                            {formatDistanceToNow(new Date(calc.lastViewedAt), { addSuffix: true, locale: sv })}
                          </span>
                        )}
                      </div>
                    ) : (
                      <span className="text-sm text-gray-400">Ej delad</span>
                    )}
                    <p className="text-xs text-gray-400 mt-1">
                      {formatDistanceToNow(new Date(calc.updatedAt), { addSuffix: true, locale: sv })}
                    </p>
                  </div>
                </div>
              </Link>
            ))
          )}
        </div>
      </div>
    </div>
  )
}
```

**src/components/dashboard/org-list.tsx:**
```typescript
import type { OrgStats } from '@/actions/dashboard'
import Link from 'next/link'

interface Props {
  orgs: OrgStats[]
}

export function OrgList({ orgs }: Props) {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
      <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Organisationer</h2>
      </div>
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gray-50 dark:bg-gray-700">
            <tr>
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Organisation</th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Kalkyler</th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Anvandare</th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Visningar</th>
              <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Typ</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
            {orgs.map((org) => (
              <tr key={org.id} className="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                <td className="px-6 py-4">
                  <Link href={`/admin/organizations/${org.id}`} className="font-medium text-blue-600 dark:text-blue-400 hover:underline">
                    {org.name}
                  </Link>
                  <p className="text-sm text-gray-500 dark:text-gray-400">{org.slug}</p>
                </td>
                <td className="px-6 py-4 text-right text-gray-900 dark:text-white">{org.calculationCount}</td>
                <td className="px-6 py-4 text-right text-gray-900 dark:text-white">{org.userCount}</td>
                <td className="px-6 py-4 text-right text-gray-900 dark:text-white">{org.totalViews}</td>
                <td className="px-6 py-4 text-right">
                  {org.isProffsKontaktAffiliated ? (
                    <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200">
                      ProffsKontakt
                    </span>
                  ) : (
                    <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200">
                      Fristående
                    </span>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

**src/components/dashboard/calculations-table.tsx:**
```typescript
'use client'

import type { CalculationForDashboard } from '@/actions/dashboard'
import Link from 'next/link'
import { formatDistanceToNow } from 'date-fns'
import { sv } from 'date-fns/locale'

interface Props {
  calculations: CalculationForDashboard[]
}

export function CalculationsTable({ calculations }: Props) {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 overflow-hidden">
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gray-50 dark:bg-gray-700">
            <tr>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Kund</th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Organisation</th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Saljare</th>
              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Batteri</th>
              <th className="px-4 py-3 text-center text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Status</th>
              <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Visningar</th>
              <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Senast visad</th>
              <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Skapad</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
            {calculations.length === 0 ? (
              <tr>
                <td colSpan={8} className="px-4 py-8 text-center text-gray-500 dark:text-gray-400">
                  Inga kalkyler hittades
                </td>
              </tr>
            ) : (
              calculations.map((calc) => (
                <tr key={calc.id} className="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                  <td className="px-4 py-3">
                    <Link href={`/dashboard/calculations/${calc.id}`} className="font-medium text-blue-600 dark:text-blue-400 hover:underline">
                      {calc.customerName}
                    </Link>
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">{calc.orgName}</td>
                  <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">{calc.closerName}</td>
                  <td className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">{calc.batteryName || '-'}</td>
                  <td className="px-4 py-3 text-center">
                    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${
                      calc.status === 'COMPLETE'
                        ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                        : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
                    }`}>
                      {calc.status === 'COMPLETE' ? 'Klar' : 'Utkast'}
                    </span>
                  </td>
                  <td className="px-4 py-3 text-right text-sm">
                    {calc.shareCode ? (
                      <span className="text-blue-600 dark:text-blue-400">{calc.viewCount}</span>
                    ) : (
                      <span className="text-gray-400">-</span>
                    )}
                  </td>
                  <td className="px-4 py-3 text-right text-sm text-gray-500 dark:text-gray-400">
                    {calc.lastViewedAt
                      ? formatDistanceToNow(new Date(calc.lastViewedAt), { addSuffix: true, locale: sv })
                      : '-'}
                  </td>
                  <td className="px-4 py-3 text-right text-sm text-gray-500 dark:text-gray-400">
                    {formatDistanceToNow(new Date(calc.createdAt), { addSuffix: true, locale: sv })}
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

Install date-fns if not already present:
```bash
npm install date-fns
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
Dashboard UI components created: DashboardStatsView, OrgList, CalculationsTable
  </done>
</task>

<task type="auto">
  <name>Task 3: Update dashboard pages with stats views</name>
  <files>
    src/app/(dashboard)/dashboard/page.tsx
    src/app/(admin)/admin/page.tsx
  </files>
  <action>
**Update src/app/(dashboard)/dashboard/page.tsx:**
Replace existing content with role-aware dashboard:

```typescript
import { redirect } from 'next/navigation'
import { auth } from '@/lib/auth/auth'
import { getDashboardStats } from '@/actions/dashboard'
import { DashboardStatsView } from '@/components/dashboard/dashboard-stats'
import { NewCalculationButton } from '@/components/calculations/new-calculation-button'
import type { Role } from '@/lib/auth/permissions'

export const metadata = {
  title: 'Dashboard - Kalkyla.se',
}

export default async function DashboardPage() {
  const session = await auth()
  if (!session?.user) redirect('/login')

  // Super Admin goes to admin panel
  const role = session.user.role as Role
  if (role === 'SUPER_ADMIN') {
    redirect('/admin')
  }

  const result = await getDashboardStats()

  if (result.error) {
    return (
      <div className="p-6 bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-lg">
        {result.error}
      </div>
    )
  }

  const stats = result.data!

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Dashboard</h1>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            Valkommen tillbaka, {session.user.name}
          </p>
        </div>
        <NewCalculationButton />
      </div>

      <DashboardStatsView
        stats={stats}
        showCloser={role === 'ORG_ADMIN'}
      />
    </div>
  )
}
```

**Create/Update src/app/(admin)/admin/page.tsx:**
```typescript
import { redirect } from 'next/navigation'
import { auth } from '@/lib/auth/auth'
import { getDashboardStats, getOrganizationsWithStats, getCalculationsForDashboard } from '@/actions/dashboard'
import { DashboardStatsView } from '@/components/dashboard/dashboard-stats'
import { OrgList } from '@/components/dashboard/org-list'
import { CalculationsTable } from '@/components/dashboard/calculations-table'
import type { Role } from '@/lib/auth/permissions'
import Link from 'next/link'

export const metadata = {
  title: 'Admin - Kalkyla.se',
}

export default async function AdminPage() {
  const session = await auth()
  if (!session?.user) redirect('/login')

  const role = session.user.role as Role
  if (role !== 'SUPER_ADMIN') {
    redirect('/dashboard')
  }

  const [statsResult, orgsResult, calcsResult] = await Promise.all([
    getDashboardStats(),
    getOrganizationsWithStats(),
    getCalculationsForDashboard(),
  ])

  if (statsResult.error || orgsResult.error || calcsResult.error) {
    return (
      <div className="p-6 bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded-lg">
        {statsResult.error || orgsResult.error || calcsResult.error}
      </div>
    )
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Admin Dashboard</h1>
        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
          Oversikt over alla organisationer och kalkyler
        </p>
      </div>

      {/* Stats overview */}
      <DashboardStatsView
        stats={statsResult.data!}
        showOrg={true}
      />

      {/* Organizations */}
      <div>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Organisationer</h2>
          <Link
            href="/admin/organizations/new"
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium"
          >
            Skapa organisation
          </Link>
        </div>
        <OrgList orgs={orgsResult.data!} />
      </div>

      {/* All calculations */}
      <div>
        <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">Alla kalkyler</h2>
        <CalculationsTable calculations={calcsResult.data!} />
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- App loads without errors
- Dashboard shows stats for logged-in user's role
- Super Admin sees all orgs and calculations
- Org Admin sees org calculations with closer names
- Closer sees own calculations with view counts
  </verify>
  <done>
Dashboard pages updated with role-based stats views and link analytics display
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build succeeds: `npm run build`
3. Dashboard loads for each role type
4. View counts and last viewed timestamps display correctly
5. Super Admin sees org list with calculation counts
6. Filterable calculations table shows all required fields
</verification>

<success_criteria>
- DASH-01: Super Admin sees all organizations with calculation counts (OrgList component)
- DASH-02: Super Admin sees all calculations (CalculationsTable, getCalculationsForDashboard with filters)
- DASH-03: Org Admin sees their org's calculations (getDashboardStats with ORG_ADMIN role)
- DASH-04: Closer sees own calculations with view counts (getDashboardStats with CLOSER role)
- DASH-05: Dashboard shows link analytics - viewCount and lastViewedAt displayed in both DashboardStatsView and CalculationsTable
</success_criteria>

<output>
After completion, create `.planning/phases/05-operations/05-03-SUMMARY.md`
</output>
