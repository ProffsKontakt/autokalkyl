---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/auth/auth.ts
  - src/lib/auth/auth.config.ts
  - src/lib/auth/credentials.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/middleware.ts
  - src/lib/auth/permissions.ts
  - src/types/next-auth.d.ts
autonomous: true

must_haves:
  truths:
    - "User can log in with email and password"
    - "User session persists across browser refresh"
    - "User can log out from any page"
    - "JWT contains user role and orgId for authorization"
  artifacts:
    - path: "src/lib/auth/auth.ts"
      provides: "Auth.js configuration"
      exports: ["auth", "signIn", "signOut"]
    - path: "src/middleware.ts"
      provides: "Route protection"
      contains: "matcher"
    - path: "src/lib/auth/permissions.ts"
      provides: "RBAC permission definitions"
      exports: ["hasPermission", "PERMISSIONS"]
  key_links:
    - from: "src/app/api/auth/[...nextauth]/route.ts"
      to: "src/lib/auth/auth.ts"
      via: "re-exports handlers"
      pattern: "export.*GET.*POST"
    - from: "src/middleware.ts"
      to: "src/lib/auth/auth.config.ts"
      via: "uses auth config"
      pattern: "authConfig"
---

<objective>
Implement Auth.js v5 with credentials authentication and role-based access control foundation.

Purpose: Enable user authentication with email/password, session persistence, and establish the RBAC permission system that enforces role hierarchy (Super Admin > Org Admin > Closer).

Output: Working authentication system with login/logout, session management, JWT claims with role/orgId, and permission checking utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Auth.js v5 with credentials provider</name>
  <files>
    src/lib/auth/auth.ts
    src/lib/auth/auth.config.ts
    src/lib/auth/credentials.ts
    src/app/api/auth/[...nextauth]/route.ts
    src/types/next-auth.d.ts
    .env.local
  </files>
  <action>
    Create Auth.js v5 configuration with credentials provider:

    **src/lib/auth/auth.config.ts** (Edge-compatible config for middleware):
    ```typescript
    import type { NextAuthConfig } from 'next-auth';

    export const authConfig = {
      pages: {
        signIn: '/login',
        error: '/login',
      },
      callbacks: {
        authorized({ auth, request: { nextUrl } }) {
          const isLoggedIn = !!auth?.user;
          const isOnDashboard = nextUrl.pathname.startsWith('/dashboard');
          const isOnAdmin = nextUrl.pathname.startsWith('/admin');
          const isOnAuth = nextUrl.pathname.startsWith('/login') ||
                           nextUrl.pathname.startsWith('/forgot-password');

          if (isOnDashboard || isOnAdmin) {
            return isLoggedIn;
          }
          if (isLoggedIn && isOnAuth) {
            return Response.redirect(new URL('/dashboard', nextUrl));
          }
          return true;
        },
      },
      providers: [], // Added in auth.ts (credentials not edge-compatible)
    } satisfies NextAuthConfig;
    ```

    **src/lib/auth/credentials.ts** (Credential validation logic):
    ```typescript
    import bcrypt from 'bcryptjs';
    import { prisma } from '@/lib/db/client';
    import { z } from 'zod';

    export const loginSchema = z.object({
      email: z.string().email(),
      password: z.string().min(8),
    });

    export async function validateCredentials(email: string, password: string) {
      const user = await prisma.user.findUnique({
        where: { email },
        include: { organization: true },
      });

      if (!user || !user.isActive) {
        return null;
      }

      const passwordMatch = await bcrypt.compare(password, user.passwordHash);
      if (!passwordMatch) {
        return null;
      }

      return {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role,
        orgId: user.orgId,
        orgSlug: user.organization?.slug,
      };
    }
    ```

    **src/lib/auth/auth.ts** (Main auth config with Prisma adapter):
    ```typescript
    import NextAuth from 'next-auth';
    import Credentials from 'next-auth/providers/credentials';
    import { PrismaAdapter } from '@auth/prisma-adapter';
    import { prisma } from '@/lib/db/client';
    import { authConfig } from './auth.config';
    import { validateCredentials, loginSchema } from './credentials';

    export const { handlers, auth, signIn, signOut } = NextAuth({
      ...authConfig,
      adapter: PrismaAdapter(prisma),
      session: { strategy: 'jwt' },
      providers: [
        Credentials({
          credentials: {
            email: { label: 'Email', type: 'email' },
            password: { label: 'Password', type: 'password' },
          },
          async authorize(credentials) {
            const parsed = loginSchema.safeParse(credentials);
            if (!parsed.success) return null;
            return validateCredentials(parsed.data.email, parsed.data.password);
          },
        }),
      ],
      callbacks: {
        ...authConfig.callbacks,
        async jwt({ token, user }) {
          if (user) {
            token.role = user.role;
            token.orgId = user.orgId;
            token.orgSlug = user.orgSlug;
          }
          return token;
        },
        async session({ session, token }) {
          if (token && session.user) {
            session.user.id = token.sub!;
            session.user.role = token.role as string;
            session.user.orgId = token.orgId as string | null;
            session.user.orgSlug = token.orgSlug as string | null;
          }
          return session;
        },
      },
    });
    ```

    **src/app/api/auth/[...nextauth]/route.ts**:
    ```typescript
    import { handlers } from '@/lib/auth/auth';
    export const { GET, POST } = handlers;
    ```

    **src/types/next-auth.d.ts** (Type augmentation):
    ```typescript
    import 'next-auth';
    import 'next-auth/jwt';

    declare module 'next-auth' {
      interface User {
        role: string;
        orgId: string | null;
        orgSlug: string | null;
      }
      interface Session {
        user: {
          id: string;
          email: string;
          name: string;
          role: string;
          orgId: string | null;
          orgSlug: string | null;
        };
      }
    }

    declare module 'next-auth/jwt' {
      interface JWT {
        role: string;
        orgId: string | null;
        orgSlug: string | null;
      }
    }
    ```

    Add to .env.local:
    ```
    NEXTAUTH_SECRET=<generate with openssl rand -base64 32>
    NEXTAUTH_URL=http://localhost:3000
    ```
  </action>
  <verify>
    - TypeScript compiles without errors
    - Auth.js route responds at /api/auth/providers
    - JWT callbacks properly extend token with role/orgId
  </verify>
  <done>Auth.js v5 configured with credentials provider, JWT sessions, and role/orgId in token</done>
</task>

<task type="auto">
  <name>Task 2: Create middleware for route protection</name>
  <files>
    src/middleware.ts
  </files>
  <action>
    Create Next.js middleware using Auth.js edge-compatible config:

    ```typescript
    import NextAuth from 'next-auth';
    import { authConfig } from '@/lib/auth/auth.config';

    export default NextAuth(authConfig).auth;

    export const config = {
      matcher: [
        /*
         * Match all request paths except:
         * - api/auth (auth endpoints)
         * - _next/static (static files)
         * - _next/image (image optimization)
         * - favicon.ico
         * - public folder
         * - public share links (/[org]/[code] pattern handled separately)
         */
        '/((?!api/auth|_next/static|_next/image|favicon.ico|public/).*)',
      ],
    };
    ```

    The middleware uses authConfig (edge-compatible) which:
    - Redirects unauthenticated users from /dashboard/* and /admin/* to /login
    - Redirects authenticated users from /login to /dashboard
    - Allows public routes to pass through

    IMPORTANT: This is FIRST layer of defense only. API routes and Server Actions MUST also verify authorization (defense in depth per PITFALLS.md #6).
  </action>
  <verify>
    - Middleware file is valid TypeScript
    - Matcher pattern excludes auth and static routes
    - Build succeeds with middleware
  </verify>
  <done>Middleware protects /dashboard and /admin routes, redirects appropriately</done>
</task>

<task type="auto">
  <name>Task 3: Implement RBAC permission system</name>
  <files>
    src/lib/auth/permissions.ts
  </files>
  <action>
    Create permission definitions and checking utilities:

    ```typescript
    export const ROLES = {
      SUPER_ADMIN: 'SUPER_ADMIN',
      ORG_ADMIN: 'ORG_ADMIN',
      CLOSER: 'CLOSER',
    } as const;

    export type Role = (typeof ROLES)[keyof typeof ROLES];

    export const PERMISSIONS = {
      // Organization permissions
      ORG_CREATE: 'org:create',
      ORG_DELETE: 'org:delete',
      ORG_VIEW_ALL: 'org:view_all',
      ORG_EDIT_ANY: 'org:edit_any',
      ORG_EDIT_OWN: 'org:edit_own',

      // User permissions
      USER_CREATE_ORG_ADMIN: 'user:create_org_admin',
      USER_CREATE_CLOSER: 'user:create_closer',
      USER_EDIT: 'user:edit',
      USER_DEACTIVATE: 'user:deactivate',
      USER_VIEW_ALL: 'user:view_all',
      USER_VIEW_ORG: 'user:view_org',

      // Calculation permissions (for future phases)
      CALC_CREATE: 'calc:create',
      CALC_VIEW_ALL: 'calc:view_all',
      CALC_VIEW_ORG: 'calc:view_org',
    } as const;

    export type Permission = (typeof PERMISSIONS)[keyof typeof PERMISSIONS];

    const ROLE_PERMISSIONS: Record<Role, Permission[]> = {
      SUPER_ADMIN: Object.values(PERMISSIONS), // All permissions
      ORG_ADMIN: [
        PERMISSIONS.ORG_EDIT_OWN,
        PERMISSIONS.USER_CREATE_CLOSER,
        PERMISSIONS.USER_EDIT,
        PERMISSIONS.USER_DEACTIVATE,
        PERMISSIONS.USER_VIEW_ORG,
        PERMISSIONS.CALC_CREATE,
        PERMISSIONS.CALC_VIEW_ORG,
      ],
      CLOSER: [
        PERMISSIONS.CALC_CREATE,
      ],
    };

    export function hasPermission(role: Role, permission: Permission): boolean {
      return ROLE_PERMISSIONS[role]?.includes(permission) ?? false;
    }

    export function requirePermission(role: Role, permission: Permission): void {
      if (!hasPermission(role, permission)) {
        throw new Error(`Permission denied: ${permission}`);
      }
    }

    // Helper to check if user can access a specific org's data
    export function canAccessOrg(
      userRole: Role,
      userOrgId: string | null,
      targetOrgId: string
    ): boolean {
      // Super Admin can access any org
      if (userRole === ROLES.SUPER_ADMIN) return true;
      // Others can only access their own org
      return userOrgId === targetOrgId;
    }
    ```

    This implements AUTH-06 (Role-based access control) with the hierarchy:
    - SUPER_ADMIN: All permissions, can access all organizations
    - ORG_ADMIN: Manage own organization, create closers
    - CLOSER: Create calculations only
  </action>
  <verify>
    - TypeScript compiles without errors
    - Permission checks return correct boolean values
    - Role hierarchy is properly defined
  </verify>
  <done>RBAC permission system with role hierarchy and permission checking utilities</done>
</task>

</tasks>

<verification>
Run these checks after all tasks complete:

1. **Type checking:**
   ```bash
   npx tsc --noEmit
   ```
   Should pass with augmented next-auth types.

2. **Build verification:**
   ```bash
   npm run build
   ```
   Should complete without errors including middleware.

3. **Auth endpoint check:**
   Start dev server and verify:
   - GET /api/auth/providers returns JSON with "credentials"
   - GET /api/auth/csrf returns CSRF token

4. **Permission system:**
   ```typescript
   // Quick test (can run in Node REPL)
   import { hasPermission, ROLES, PERMISSIONS } from './src/lib/auth/permissions';
   console.log(hasPermission('SUPER_ADMIN', 'org:create')); // true
   console.log(hasPermission('CLOSER', 'org:create')); // false
   ```
</verification>

<success_criteria>
- Auth.js v5 configured with credentials provider
- JWT contains role, orgId, orgSlug claims
- Middleware protects /dashboard and /admin routes
- Permission system enforces role hierarchy
- TypeScript types properly augmented for session
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
