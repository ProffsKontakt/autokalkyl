---
phase: 01-foundation
plan: 06
type: execute
wave: 5
depends_on: ["01-05"]
files_modified:
  - src/app/(auth)/forgot-password/page.tsx
  - src/app/(auth)/forgot-password/forgot-password-form.tsx
  - src/app/(auth)/reset-password/page.tsx
  - src/app/(auth)/reset-password/reset-password-form.tsx
  - src/actions/password-reset.ts
  - src/lib/email/send-reset-email.ts
autonomous: true
user_setup:
  - service: n8n
    why: "Email sending via Gmail"
    env_vars:
      - name: N8N_WEBHOOK_URL
        source: "Your N8N instance -> Webhook node -> Production URL"
    dashboard_config:
      - task: "Create password reset email workflow"
        location: "N8N -> Create new workflow -> Add Webhook + Gmail nodes"

must_haves:
  truths:
    - "User can request password reset via email"
    - "User receives email with reset link"
    - "User can set new password via reset link"
    - "Reset links expire after 1 hour"
    - "Used reset links cannot be reused"
  artifacts:
    - path: "src/app/(auth)/forgot-password/page.tsx"
      provides: "Forgot password page"
      min_lines: 15
    - path: "src/actions/password-reset.ts"
      provides: "Password reset server actions"
      exports: ["requestPasswordReset", "resetPassword"]
    - path: "src/lib/email/send-reset-email.ts"
      provides: "N8N webhook integration"
      exports: ["sendPasswordResetEmail"]
  key_links:
    - from: "src/actions/password-reset.ts"
      to: "src/lib/email/send-reset-email.ts"
      via: "calls webhook"
      pattern: "sendPasswordResetEmail"
    - from: "src/app/(auth)/reset-password/page.tsx"
      to: "src/actions/password-reset.ts"
      via: "form submission"
      pattern: "resetPassword"
---

<objective>
Implement password reset flow with email delivery via N8N webhook to Gmail.

Purpose: Allow users who have forgotten their password to reset it via email link. Implements AUTH-05 (password reset via email).

Output: Forgot password page, reset password page, server actions for token generation/validation, and N8N webhook integration for email sending.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
@.planning/phases/01-foundation/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create password reset server actions</name>
  <files>
    src/actions/password-reset.ts
    src/lib/email/send-reset-email.ts
    .env.example
  </files>
  <action>
    Create server actions for password reset flow:

    **src/lib/email/send-reset-email.ts:**
    ```typescript
    export async function sendPasswordResetEmail(
      email: string,
      resetUrl: string,
      userName: string
    ): Promise<{ success: boolean; error?: string }> {
      const webhookUrl = process.env.N8N_WEBHOOK_URL;

      if (!webhookUrl) {
        console.error('N8N_WEBHOOK_URL not configured');
        // In development, just log the reset link
        if (process.env.NODE_ENV === 'development') {
          console.log('========================================');
          console.log('PASSWORD RESET LINK (dev mode):');
          console.log(resetUrl);
          console.log('========================================');
          return { success: true };
        }
        return { error: 'Email service not configured' };
      }

      try {
        const response = await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            type: 'password_reset',
            to: email,
            userName,
            resetUrl,
            subject: 'Återställ ditt lösenord - Kalkyla.se',
          }),
        });

        if (!response.ok) {
          throw new Error(`N8N webhook failed: ${response.status}`);
        }

        return { success: true };
      } catch (error) {
        console.error('Failed to send password reset email:', error);
        return { error: 'Kunde inte skicka e-post' };
      }
    }
    ```

    **src/actions/password-reset.ts:**
    ```typescript
    'use server';

    import { z } from 'zod';
    import crypto from 'crypto';
    import bcrypt from 'bcryptjs';
    import { prisma } from '@/lib/db/client';
    import { sendPasswordResetEmail } from '@/lib/email/send-reset-email';

    const requestSchema = z.object({
      email: z.string().email('Ogiltig e-postadress'),
    });

    const resetSchema = z.object({
      token: z.string().min(1),
      password: z.string().min(8, 'Lösenordet måste vara minst 8 tecken'),
      confirmPassword: z.string(),
    }).refine((data) => data.password === data.confirmPassword, {
      message: 'Lösenorden matchar inte',
      path: ['confirmPassword'],
    });

    export async function requestPasswordReset(data: { email: string }) {
      const parsed = requestSchema.safeParse(data);
      if (!parsed.success) {
        return { error: parsed.error.errors[0].message };
      }

      const user = await prisma.user.findUnique({
        where: { email: parsed.data.email },
      });

      // Always return success to prevent email enumeration
      if (!user || !user.isActive) {
        return { success: true };
      }

      // Delete any existing tokens for this user
      await prisma.passwordResetToken.deleteMany({
        where: { userId: user.id },
      });

      // Generate secure token
      const token = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

      await prisma.passwordResetToken.create({
        data: {
          token,
          userId: user.id,
          expiresAt,
        },
      });

      // Build reset URL
      const baseUrl = process.env.NEXTAUTH_URL || 'http://localhost:3000';
      const resetUrl = `${baseUrl}/reset-password?token=${token}`;

      // Send email via N8N
      const emailResult = await sendPasswordResetEmail(
        user.email,
        resetUrl,
        user.name
      );

      if (emailResult.error) {
        console.error('Email send failed:', emailResult.error);
        // Still return success to prevent information leakage
      }

      return { success: true };
    }

    export async function resetPassword(data: {
      token: string;
      password: string;
      confirmPassword: string;
    }) {
      const parsed = resetSchema.safeParse(data);
      if (!parsed.success) {
        return { error: parsed.error.errors[0].message };
      }

      // Find valid token
      const resetToken = await prisma.passwordResetToken.findUnique({
        where: { token: parsed.data.token },
        include: { user: true },
      });

      if (!resetToken) {
        return { error: 'Ogiltig eller utgången länk' };
      }

      // Check expiration
      if (resetToken.expiresAt < new Date()) {
        await prisma.passwordResetToken.delete({ where: { id: resetToken.id } });
        return { error: 'Länken har gått ut. Begär en ny.' };
      }

      // Check if already used
      if (resetToken.usedAt) {
        return { error: 'Denna länk har redan använts' };
      }

      // Hash new password
      const passwordHash = await bcrypt.hash(parsed.data.password, 12);

      // Update password and mark token as used
      await prisma.$transaction([
        prisma.user.update({
          where: { id: resetToken.userId },
          data: { passwordHash },
        }),
        prisma.passwordResetToken.update({
          where: { id: resetToken.id },
          data: { usedAt: new Date() },
        }),
      ]);

      return { success: true };
    }

    export async function validateResetToken(token: string) {
      const resetToken = await prisma.passwordResetToken.findUnique({
        where: { token },
      });

      if (!resetToken) {
        return { valid: false, error: 'Ogiltig länk' };
      }

      if (resetToken.expiresAt < new Date()) {
        return { valid: false, error: 'Länken har gått ut' };
      }

      if (resetToken.usedAt) {
        return { valid: false, error: 'Länken har redan använts' };
      }

      return { valid: true };
    }
    ```

    Update **.env.example:**
    ```
    # N8N Integration (for email sending)
    N8N_WEBHOOK_URL=https://your-n8n-instance.com/webhook/password-reset
    ```
  </action>
  <verify>
    - Server actions compile without TypeScript errors
    - Token generation uses cryptographically secure random bytes
    - Token expiration is properly checked
    - Used tokens cannot be reused
  </verify>
  <done>Password reset server actions with secure token handling and N8N integration</done>
</task>

<task type="auto">
  <name>Task 2: Create forgot password page</name>
  <files>
    src/app/(auth)/forgot-password/page.tsx
    src/app/(auth)/forgot-password/forgot-password-form.tsx
  </files>
  <action>
    Create forgot password page and form:

    **src/app/(auth)/forgot-password/page.tsx:**
    ```typescript
    import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
    import { ForgotPasswordForm } from './forgot-password-form';

    export const metadata = {
      title: 'Glömt lösenord - Kalkyla.se',
      description: 'Återställ ditt lösenord',
    };

    export default function ForgotPasswordPage() {
      return (
        <Card>
          <CardHeader>
            <CardTitle className="text-center">Glömt lösenord?</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-gray-600 mb-4 text-center">
              Ange din e-postadress så skickar vi en länk för att återställa ditt lösenord.
            </p>
            <ForgotPasswordForm />
          </CardContent>
        </Card>
      );
    }
    ```

    **src/app/(auth)/forgot-password/forgot-password-form.tsx:**
    ```typescript
    'use client';

    import { useForm } from 'react-hook-form';
    import { zodResolver } from '@hookform/resolvers/zod';
    import { z } from 'zod';
    import { useState, useTransition } from 'react';
    import Link from 'next/link';

    import { Button } from '@/components/ui/button';
    import { Input } from '@/components/ui/input';
    import { Label } from '@/components/ui/label';
    import { requestPasswordReset } from '@/actions/password-reset';

    const forgotPasswordSchema = z.object({
      email: z.string().email('Ogiltig e-postadress'),
    });

    type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>;

    export function ForgotPasswordForm() {
      const [success, setSuccess] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [isPending, startTransition] = useTransition();

      const {
        register,
        handleSubmit,
        formState: { errors },
      } = useForm<ForgotPasswordFormData>({
        resolver: zodResolver(forgotPasswordSchema),
      });

      const onSubmit = (data: ForgotPasswordFormData) => {
        setError(null);
        startTransition(async () => {
          const result = await requestPasswordReset(data);
          if (result.error) {
            setError(result.error);
          } else {
            setSuccess(true);
          }
        });
      };

      if (success) {
        return (
          <div className="text-center space-y-4">
            <div className="p-3 bg-green-50 border border-green-200 rounded-md text-green-700 text-sm">
              Om det finns ett konto med denna e-postadress har vi skickat instruktioner för att återställa lösenordet.
            </div>
            <Link href="/login" className="text-sm text-blue-600 hover:underline">
              Tillbaka till inloggning
            </Link>
          </div>
        );
      }

      return (
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {error && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="space-y-2">
            <Label htmlFor="email">E-postadress</Label>
            <Input
              id="email"
              type="email"
              placeholder="namn@företag.se"
              {...register('email')}
            />
            {errors.email && (
              <p className="text-sm text-red-600">{errors.email.message}</p>
            )}
          </div>

          <Button type="submit" className="w-full" disabled={isPending}>
            {isPending ? 'Skickar...' : 'Skicka återställningslänk'}
          </Button>

          <div className="text-center">
            <Link href="/login" className="text-sm text-blue-600 hover:underline">
              Tillbaka till inloggning
            </Link>
          </div>
        </form>
      );
    }
    ```
  </action>
  <verify>
    - Forgot password page renders at /forgot-password
    - Form validates email format
    - Success message shows after submission (even for non-existent emails)
    - Link back to login works
  </verify>
  <done>Forgot password page with email input and success state</done>
</task>

<task type="auto">
  <name>Task 3: Create reset password page</name>
  <files>
    src/app/(auth)/reset-password/page.tsx
    src/app/(auth)/reset-password/reset-password-form.tsx
  </files>
  <action>
    Create reset password page that accepts token from URL:

    **src/app/(auth)/reset-password/page.tsx:**
    ```typescript
    import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
    import { ResetPasswordForm } from './reset-password-form';
    import { validateResetToken } from '@/actions/password-reset';
    import Link from 'next/link';

    export const metadata = {
      title: 'Återställ lösenord - Kalkyla.se',
    };

    interface ResetPasswordPageProps {
      searchParams: Promise<{ token?: string }>;
    }

    export default async function ResetPasswordPage({
      searchParams,
    }: ResetPasswordPageProps) {
      const { token } = await searchParams;

      if (!token) {
        return (
          <Card>
            <CardHeader>
              <CardTitle className="text-center">Ogiltig länk</CardTitle>
            </CardHeader>
            <CardContent className="text-center">
              <p className="text-sm text-gray-600 mb-4">
                Länken för att återställa lösenord saknas eller är ogiltig.
              </p>
              <Link href="/forgot-password" className="text-blue-600 hover:underline">
                Begär en ny återställningslänk
              </Link>
            </CardContent>
          </Card>
        );
      }

      const { valid, error } = await validateResetToken(token);

      if (!valid) {
        return (
          <Card>
            <CardHeader>
              <CardTitle className="text-center">Länken är ogiltig</CardTitle>
            </CardHeader>
            <CardContent className="text-center">
              <p className="text-sm text-gray-600 mb-4">{error}</p>
              <Link href="/forgot-password" className="text-blue-600 hover:underline">
                Begär en ny återställningslänk
              </Link>
            </CardContent>
          </Card>
        );
      }

      return (
        <Card>
          <CardHeader>
            <CardTitle className="text-center">Välj nytt lösenord</CardTitle>
          </CardHeader>
          <CardContent>
            <ResetPasswordForm token={token} />
          </CardContent>
        </Card>
      );
    }
    ```

    **src/app/(auth)/reset-password/reset-password-form.tsx:**
    ```typescript
    'use client';

    import { useForm } from 'react-hook-form';
    import { zodResolver } from '@hookform/resolvers/zod';
    import { z } from 'zod';
    import { useState, useTransition } from 'react';
    import { useRouter } from 'next/navigation';
    import Link from 'next/link';

    import { Button } from '@/components/ui/button';
    import { Input } from '@/components/ui/input';
    import { Label } from '@/components/ui/label';
    import { resetPassword } from '@/actions/password-reset';

    const resetPasswordSchema = z.object({
      password: z.string().min(8, 'Lösenordet måste vara minst 8 tecken'),
      confirmPassword: z.string(),
    }).refine((data) => data.password === data.confirmPassword, {
      message: 'Lösenorden matchar inte',
      path: ['confirmPassword'],
    });

    type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>;

    interface ResetPasswordFormProps {
      token: string;
    }

    export function ResetPasswordForm({ token }: ResetPasswordFormProps) {
      const [success, setSuccess] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [isPending, startTransition] = useTransition();
      const router = useRouter();

      const {
        register,
        handleSubmit,
        formState: { errors },
      } = useForm<ResetPasswordFormData>({
        resolver: zodResolver(resetPasswordSchema),
      });

      const onSubmit = (data: ResetPasswordFormData) => {
        setError(null);
        startTransition(async () => {
          const result = await resetPassword({
            token,
            password: data.password,
            confirmPassword: data.confirmPassword,
          });

          if (result.error) {
            setError(result.error);
          } else {
            setSuccess(true);
            // Redirect to login after 3 seconds
            setTimeout(() => {
              router.push('/login');
            }, 3000);
          }
        });
      };

      if (success) {
        return (
          <div className="text-center space-y-4">
            <div className="p-3 bg-green-50 border border-green-200 rounded-md text-green-700 text-sm">
              Ditt lösenord har återställts! Du dirigeras nu till inloggningen...
            </div>
            <Link href="/login" className="text-sm text-blue-600 hover:underline">
              Gå till inloggning nu
            </Link>
          </div>
        );
      }

      return (
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {error && (
            <div className="p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
              {error}
            </div>
          )}

          <div className="space-y-2">
            <Label htmlFor="password">Nytt lösenord</Label>
            <Input
              id="password"
              type="password"
              {...register('password')}
            />
            {errors.password && (
              <p className="text-sm text-red-600">{errors.password.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Bekräfta lösenord</Label>
            <Input
              id="confirmPassword"
              type="password"
              {...register('confirmPassword')}
            />
            {errors.confirmPassword && (
              <p className="text-sm text-red-600">{errors.confirmPassword.message}</p>
            )}
          </div>

          <Button type="submit" className="w-full" disabled={isPending}>
            {isPending ? 'Sparar...' : 'Spara nytt lösenord'}
          </Button>
        </form>
      );
    }
    ```
  </action>
  <verify>
    - Reset password page validates token from URL
    - Invalid/expired tokens show appropriate error
    - Form validates password requirements
    - Passwords must match
    - Success state redirects to login
  </verify>
  <done>Reset password page with token validation and password confirmation</done>
</task>

</tasks>

<verification>
Run these checks after all tasks complete:

1. **Type checking:**
   ```bash
   npx tsc --noEmit
   ```

2. **Build verification:**
   ```bash
   npm run build
   ```

3. **Full password reset flow test:**
   a. Navigate to /login
   b. Click "Glömt lösenord?"
   c. Enter valid email (e.g., admin@test-solar.se)
   d. Submit - see success message
   e. Check console for reset link (dev mode)
   f. Visit reset link
   g. Enter new password
   h. Submit - redirected to login
   i. Log in with new password

4. **Edge case testing:**
   - Invalid token shows error
   - Expired token (if testable) shows error
   - Reusing token shows "already used" error
   - Non-existent email still shows success (prevents enumeration)
</verification>

<success_criteria>
- Users can request password reset via email
- Reset links contain secure tokens
- Tokens expire after 1 hour
- Used tokens cannot be reused
- N8N webhook sends emails (or logs in dev)
- Password reset completes successfully
- All error cases handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-06-SUMMARY.md`
</output>
