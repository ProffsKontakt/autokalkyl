---
phase: 03-calculator-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/calculations/engine.ts
  - src/lib/calculations/formulas.ts
  - src/lib/calculations/types.ts
  - src/lib/calculations/constants.ts
  - src/lib/calculations/presets.ts
  - src/lib/calculations/elomrade-lookup.ts
  - src/lib/auth/permissions.ts
autonomous: true

must_haves:
  truths:
    - "Calculation model stores customer info, consumption profile, and battery selections"
    - "Calculation engine produces accurate ROI results using decimal.js precision"
    - "LOGIC-01 through LOGIC-10 formulas return correct values"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Calculation and CalculationBattery models"
      contains: "model Calculation"
    - path: "src/lib/calculations/engine.ts"
      provides: "calculateBatteryROI function"
      exports: ["calculateBatteryROI", "serializeResults"]
    - path: "src/lib/calculations/formulas.ts"
      provides: "Individual formula functions"
      exports: ["calcEffectiveCapacity", "calcAnnualEnergy", "calcSpotprisSavings"]
    - path: "src/lib/calculations/types.ts"
      provides: "TypeScript types for calculations"
      exports: ["CalculationInputs", "CalculationResults", "ConsumptionProfile"]
  key_links:
    - from: "src/lib/calculations/engine.ts"
      to: "decimal.js"
      via: "import Decimal"
      pattern: "import Decimal from 'decimal.js'"
    - from: "prisma/schema.prisma"
      to: "Natagare model"
      via: "relation"
      pattern: "natagareId.*String"
---

<objective>
Create database schema for calculations and implement the core ROI calculation engine with all LOGIC-01 through LOGIC-10 formulas using decimal.js for financial precision.

Purpose: Foundation for all calculator functionality - without the schema and calculation engine, no other calculator features can work.

Output: Prisma Calculation/CalculationBattery models, TypeScript types, calculation engine with formulas, consumption presets, and elomrade lookup.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calculator-engine/03-CONTEXT.md
@.planning/phases/03-calculator-engine/03-RESEARCH.md

# Prior phase context
@.planning/phases/02-reference-data/02-01-SUMMARY.md

# Existing code patterns
@prisma/schema.prisma
@src/lib/auth/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with Calculation models</name>
  <files>prisma/schema.prisma, src/lib/auth/permissions.ts</files>
  <action>
Add to prisma/schema.prisma:

1. Add CalculationStatus enum:
   - DRAFT (auto-saved, not complete)
   - COMPLETE (finalized)
   - ARCHIVED (soft-deleted)

2. Add Calculation model with fields:
   - id: String @id @default(cuid())
   - orgId: String (tenant scoping)
   - createdBy: String (user ID who created)
   - status: CalculationStatus @default(DRAFT)

   Customer Info (Step 1):
   - customerName: String
   - postalCode: String? (optional, used for elomrade auto-detect)
   - elomrade: Elomrade
   - natagareId: String (relation to Natagare)
   - annualConsumptionKwh: Decimal @db.Decimal(10, 2)

   Consumption Profile (Step 2):
   - consumptionProfile: Json (stores { data: number[][] } where [month][hour])

   Results:
   - results: Json? (calculated results, null for drafts)

   Metadata:
   - shareCode: String? @unique (for Phase 4 public sharing)
   - createdAt: DateTime @default(now())
   - updatedAt: DateTime @updatedAt
   - finalizedAt: DateTime?

   Relations:
   - organization: Organization @relation(...)
   - natagare: Natagare @relation(...)
   - batteries: CalculationBattery[]

   Indexes:
   - @@index([orgId])
   - @@index([createdBy])
   - @@index([shareCode])

3. Add CalculationBattery model (junction table for multi-battery comparison):
   - id: String @id @default(cuid())
   - calculationId: String
   - batteryConfigId: String
   - totalPriceExVat: Decimal @db.Decimal(10, 2)
   - installationCost: Decimal @db.Decimal(10, 2)
   - results: Json? (per-battery calculated results)
   - sortOrder: Int @default(0)

   Relations:
   - calculation: Calculation @relation(...)
   - batteryConfig: BatteryConfig @relation(...)

   Constraints:
   - @@unique([calculationId, batteryConfigId])
   - @@index([calculationId])

4. Update Organization model to add calculations relation:
   - calculations: Calculation[]

5. Update Natagare model to add calculations relation:
   - calculations: Calculation[]

6. Update BatteryConfig model to add calculationBatteries relation:
   - calculationBatteries: CalculationBattery[]

Add to src/lib/auth/permissions.ts:
- CALCULATION_CREATE: Closer, Org Admin
- CALCULATION_VIEW: Closer (own), Org Admin (org), Super Admin (all)
- CALCULATION_EDIT: Closer (own), Org Admin (org)
- CALCULATION_DELETE: Closer (own), Org Admin (org)
- CALCULATION_FINALIZE: Closer (own), Org Admin (org)

Run: npx prisma generate (note: db push will fail without network, that's expected)
  </action>
  <verify>npx prisma validate && npx prisma generate</verify>
  <done>Calculation and CalculationBattery models defined with all fields, relations, and indexes; permissions added for calculation operations</done>
</task>

<task type="auto">
  <name>Task 2: Create calculation types, constants, and utility modules</name>
  <files>src/lib/calculations/types.ts, src/lib/calculations/constants.ts, src/lib/calculations/presets.ts, src/lib/calculations/elomrade-lookup.ts</files>
  <action>
Create src/lib/calculations/types.ts:
```typescript
import type Decimal from 'decimal.js'

export interface ConsumptionProfile {
  data: number[][] // [month][hour] - 12 months x 24 hours
}

export interface BatterySpec {
  capacityKwh: number
  chargeEfficiency: number      // percentage, e.g., 95
  dischargeEfficiency: number   // percentage, e.g., 97
  maxDischargeKw: number
  maxChargeKw: number
  costPrice: number             // SEK
}

export interface CalculationInputs {
  battery: BatterySpec
  cyclesPerDay: number          // typically 1-2
  avgDischargePercent: number   // percentage, e.g., 85
  dayPriceOre: number           // average day price ore/kWh
  nightPriceOre: number         // average night price ore/kWh
  effectTariffDayRate: number   // SEK/kW (from natagare)
  effectTariffNightRate: number // SEK/kW (from natagare)
  gridServicesRatePerKwYear: number // default 500 SEK/kW/year
  totalPriceExVat: number       // SEK
  installationCost: number      // SEK
  vatRate: number               // 0.25 for 25%
  gronTeknikRate: number        // 0.485 for 48.5%
  // For margin calculation (ProffsKontakt affiliates only)
  installerCut?: number         // SEK
  batteryCostPrice?: number     // SEK
}

export interface CalculationResults {
  effectiveCapacityPerCycleKwh: number
  energyFromBatteryPerYearKwh: number
  spotprisSavingsSek: number
  effectTariffSavingsSek: number
  gridServicesIncomeSek: number
  totalAnnualSavingsSek: number
  totalIncVatSek: number
  costAfterGronTeknikSek: number
  marginSek?: number
  paybackPeriodYears: number
  roi10YearPercent: number
  roi15YearPercent: number
}

export type Elomrade = 'SE1' | 'SE2' | 'SE3' | 'SE4'
```

Create src/lib/calculations/constants.ts:
```typescript
// Business constants
export const VAT_RATE = 0.25 // 25%
export const GRON_TEKNIK_RATE = 0.485 // 48.5% deduction
export const DEFAULT_GRID_SERVICES_RATE = 500 // SEK/kW/year
export const DEFAULT_CYCLES_PER_DAY = 1
export const DEFAULT_AVG_DISCHARGE_PERCENT = 85
export const DEFAULT_ANNUAL_CONSUMPTION_KWH = 20000

// Time windows (same as natagare defaults)
export const DEFAULT_DAY_START_HOUR = 6
export const DEFAULT_DAY_END_HOUR = 22

// Months and hours
export const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec']
export const HOURS = Array.from({ length: 24 }, (_, i) => i)
```

Create src/lib/calculations/presets.ts (from RESEARCH.md pattern):
```typescript
export interface ConsumptionPreset {
  id: string
  name: string
  description: string
  hourlyPattern: number[]   // 24 values
  monthlyFactors: number[]  // 12 values
}

export const SYSTEM_PRESETS: ConsumptionPreset[] = [
  {
    id: 'electric-heating',
    name: 'Elvarmning',
    description: 'Hog forbrukning vinter, lag sommar, jamn over dygnet',
    hourlyPattern: [3, 3, 2, 2, 2, 3, 5, 6, 5, 4, 4, 4, 4, 4, 4, 5, 6, 7, 6, 5, 5, 4, 4, 3],
    monthlyFactors: [1.5, 1.4, 1.2, 0.9, 0.6, 0.4, 0.3, 0.4, 0.6, 0.9, 1.2, 1.5],
  },
  {
    id: 'heat-pump',
    name: 'Varmepump',
    description: 'Hog forbrukning morgon/kvall, lag mitt pa dagen',
    hourlyPattern: [3, 2, 2, 2, 2, 4, 7, 8, 5, 3, 3, 3, 3, 3, 3, 4, 6, 8, 7, 5, 4, 4, 3, 3],
    monthlyFactors: [1.3, 1.2, 1.0, 0.8, 0.7, 0.6, 0.6, 0.7, 0.8, 1.0, 1.2, 1.4],
  },
  {
    id: 'ev-charging',
    name: 'Elbilsladdning',
    description: 'Huvudsakligen nattetid, nagot kvall',
    hourlyPattern: [8, 8, 8, 8, 6, 4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 6, 7, 8, 8, 8],
    monthlyFactors: [1.0, 1.0, 1.0, 1.0, 1.0, 0.9, 0.8, 0.9, 1.0, 1.0, 1.1, 1.1],
  },
  {
    id: 'solar-prosumer',
    name: 'Solcellsproducent',
    description: 'Lag egenanvandning dagtid tack vare solceller',
    hourlyPattern: [5, 4, 4, 3, 3, 4, 5, 3, 1, 1, 1, 1, 1, 1, 1, 2, 4, 6, 7, 7, 6, 5, 5, 5],
    monthlyFactors: [1.2, 1.1, 0.9, 0.7, 0.5, 0.4, 0.5, 0.6, 0.8, 1.0, 1.1, 1.2],
  },
]

export function applyPreset(preset: ConsumptionPreset, annualKwh: number): number[][] {
  const totalPatternSum = preset.hourlyPattern.reduce((a, b) => a + b, 0)
  const totalMonthlySum = preset.monthlyFactors.reduce((a, b) => a + b, 0)
  const avgMonthlyKwh = annualKwh / 12
  const monthlyTotals = preset.monthlyFactors.map(
    factor => avgMonthlyKwh * factor * (12 / totalMonthlySum)
  )
  return monthlyTotals.map(monthTotal => {
    return preset.hourlyPattern.map(
      pct => (monthTotal / 30) * (pct / totalPatternSum)
    )
  })
}

export function createEmptyProfile(): number[][] {
  return Array(12).fill(null).map(() => Array(24).fill(0))
}
```

Create src/lib/calculations/elomrade-lookup.ts:
```typescript
import type { Elomrade } from './types'

interface PostalCodeRange {
  start: number
  end: number
  elomrade: Elomrade
}

const POSTAL_CODE_RANGES: PostalCodeRange[] = [
  // SE1: Norrbotten (95xxx-98xxx)
  { start: 95000, end: 98999, elomrade: 'SE1' },
  // SE2: Jamtland, Vasternorrland, Dalarna (80xxx-89xxx)
  { start: 80000, end: 89999, elomrade: 'SE2' },
  // SE4: Skane, Blekinge (20xxx-29xxx)
  { start: 20000, end: 29999, elomrade: 'SE4' },
  // SE4: Kalmar (30xxx-39xxx)
  { start: 30000, end: 39999, elomrade: 'SE4' },
  // SE3: Everything else (10xxx-79xxx) - default/largest region
  { start: 10000, end: 79999, elomrade: 'SE3' },
]

export function lookupElomrade(postalCode: string): Elomrade | null {
  const cleaned = postalCode.replace(/\s/g, '')
  if (!/^\d{5}$/.test(cleaned)) return null
  const code = parseInt(cleaned, 10)
  for (const range of POSTAL_CODE_RANGES) {
    if (code >= range.start && code <= range.end) {
      return range.elomrade
    }
  }
  return 'SE3' // Default to largest region
}

export function isValidSwedishPostalCode(postalCode: string): boolean {
  const cleaned = postalCode.replace(/\s/g, '')
  return /^\d{5}$/.test(cleaned)
}
```
  </action>
  <verify>npx tsc --noEmit src/lib/calculations/types.ts src/lib/calculations/constants.ts src/lib/calculations/presets.ts src/lib/calculations/elomrade-lookup.ts</verify>
  <done>Types, constants, presets, and elomrade lookup modules compile without errors</done>
</task>

<task type="auto">
  <name>Task 3: Implement calculation engine with decimal.js</name>
  <files>src/lib/calculations/formulas.ts, src/lib/calculations/engine.ts</files>
  <action>
First install decimal.js:
```bash
npm install decimal.js
```

Create src/lib/calculations/formulas.ts (individual formula functions for testability):
```typescript
import Decimal from 'decimal.js'

// Configure decimal.js for financial calculations
Decimal.set({ precision: 20, rounding: Decimal.ROUND_HALF_UP })

// Helper to create Decimal from number
const d = (n: number) => new Decimal(n)

// LOGIC-01: Effective capacity per cycle
export function calcEffectiveCapacity(
  capacityKwh: number,
  chargeEfficiency: number,   // percentage, e.g., 95
  dischargeEfficiency: number, // percentage, e.g., 97
  avgDischargePercent: number  // percentage, e.g., 85
): Decimal {
  return d(capacityKwh)
    .times(d(chargeEfficiency).div(100))
    .times(d(dischargeEfficiency).div(100))
    .times(d(avgDischargePercent).div(100))
}

// LOGIC-02: Annual energy from battery
export function calcAnnualEnergy(effectiveCapacityKwh: Decimal, cyclesPerDay: number): Decimal {
  return effectiveCapacityKwh.times(cyclesPerDay).times(365)
}

// LOGIC-03: Spotpris optimization savings
export function calcSpotprisSavings(
  annualEnergyKwh: Decimal,
  dayPriceOre: number,
  nightPriceOre: number
): Decimal {
  const priceDiff = d(dayPriceOre).minus(nightPriceOre)
  return annualEnergyKwh.times(priceDiff).div(100) // ore to SEK
}

// LOGIC-04: Effect tariff savings (simplified - uses average peak reduction)
export function calcEffectTariffSavings(
  maxDischargeKw: number,
  effectTariffDayRate: number
): Decimal {
  // Estimate: battery can reduce peak by its max discharge capacity
  // Applied over 12 months with day rate
  return d(maxDischargeKw).times(effectTariffDayRate).times(12)
}

// LOGIC-05: Grid services income
export function calcGridServicesIncome(
  maxDischargeKw: number,
  ratePerKwYear: number
): Decimal {
  return d(maxDischargeKw).times(ratePerKwYear)
}

// LOGIC-06: Total annual savings
export function calcTotalAnnualSavings(
  spotprisSavings: Decimal,
  effectTariffSavings: Decimal,
  gridServicesIncome: Decimal
): Decimal {
  return spotprisSavings.plus(effectTariffSavings).plus(gridServicesIncome)
}

// CALC-11: Total including VAT
export function calcTotalIncVat(
  totalPriceExVat: number,
  installationCost: number,
  vatRate: number
): Decimal {
  const totalExVat = d(totalPriceExVat).plus(installationCost)
  return totalExVat.times(d(1).plus(vatRate))
}

// CALC-12: Cost after Gron Teknik deduction
export function calcCostAfterGronTeknik(totalIncVat: Decimal, gronTeknikRate: number): Decimal {
  const deduction = totalIncVat.times(gronTeknikRate)
  return totalIncVat.minus(deduction)
}

// CALC-13: Margin calculation (for ProffsKontakt affiliates)
export function calcMargin(
  totalPriceExVat: number,
  batteryCostPrice: number,
  installerCut: number
): Decimal {
  return d(totalPriceExVat).minus(batteryCostPrice).minus(installerCut)
}

// LOGIC-07: Payback period in years
export function calcPaybackPeriod(costAfterGronTeknik: Decimal, annualSavings: Decimal): Decimal {
  if (annualSavings.isZero()) return d(999) // Avoid division by zero
  return costAfterGronTeknik.div(annualSavings)
}

// LOGIC-08: 10-year ROI percentage
export function calcRoi10Year(costAfterGronTeknik: Decimal, annualSavings: Decimal): Decimal {
  if (costAfterGronTeknik.isZero()) return d(0)
  const totalSavings = annualSavings.times(10)
  return totalSavings.minus(costAfterGronTeknik).div(costAfterGronTeknik).times(100)
}

// LOGIC-09: 15-year ROI percentage
export function calcRoi15Year(costAfterGronTeknik: Decimal, annualSavings: Decimal): Decimal {
  if (costAfterGronTeknik.isZero()) return d(0)
  const totalSavings = annualSavings.times(15)
  return totalSavings.minus(costAfterGronTeknik).div(costAfterGronTeknik).times(100)
}
```

Create src/lib/calculations/engine.ts (orchestrates all formulas):
```typescript
import Decimal from 'decimal.js'
import type { CalculationInputs, CalculationResults } from './types'
import {
  calcEffectiveCapacity,
  calcAnnualEnergy,
  calcSpotprisSavings,
  calcEffectTariffSavings,
  calcGridServicesIncome,
  calcTotalAnnualSavings,
  calcTotalIncVat,
  calcCostAfterGronTeknik,
  calcMargin,
  calcPaybackPeriod,
  calcRoi10Year,
  calcRoi15Year,
} from './formulas'

// LOGIC-10: Main calculation function using decimal.js for precision
export function calculateBatteryROI(inputs: CalculationInputs): {
  results: CalculationResults
  decimals: {
    effectiveCapacityPerCycleKwh: Decimal
    energyFromBatteryPerYearKwh: Decimal
    spotprisSavingsSek: Decimal
    effectTariffSavingsSek: Decimal
    gridServicesIncomeSek: Decimal
    totalAnnualSavingsSek: Decimal
    totalIncVatSek: Decimal
    costAfterGronTeknikSek: Decimal
    marginSek?: Decimal
    paybackPeriodYears: Decimal
    roi10YearPercent: Decimal
    roi15YearPercent: Decimal
  }
} {
  // LOGIC-01
  const effectiveCapacity = calcEffectiveCapacity(
    inputs.battery.capacityKwh,
    inputs.battery.chargeEfficiency,
    inputs.battery.dischargeEfficiency,
    inputs.avgDischargePercent
  )

  // LOGIC-02
  const annualEnergy = calcAnnualEnergy(effectiveCapacity, inputs.cyclesPerDay)

  // LOGIC-03
  const spotprisSavings = calcSpotprisSavings(
    annualEnergy,
    inputs.dayPriceOre,
    inputs.nightPriceOre
  )

  // LOGIC-04
  const effectTariffSavings = calcEffectTariffSavings(
    inputs.battery.maxDischargeKw,
    inputs.effectTariffDayRate
  )

  // LOGIC-05
  const gridServicesIncome = calcGridServicesIncome(
    inputs.battery.maxDischargeKw,
    inputs.gridServicesRatePerKwYear
  )

  // LOGIC-06
  const totalAnnualSavings = calcTotalAnnualSavings(
    spotprisSavings,
    effectTariffSavings,
    gridServicesIncome
  )

  // CALC-11
  const totalIncVat = calcTotalIncVat(
    inputs.totalPriceExVat,
    inputs.installationCost,
    inputs.vatRate
  )

  // CALC-12
  const costAfterGronTeknik = calcCostAfterGronTeknik(totalIncVat, inputs.gronTeknikRate)

  // CALC-13 (optional)
  let marginSek: Decimal | undefined
  if (inputs.installerCut !== undefined && inputs.batteryCostPrice !== undefined) {
    marginSek = calcMargin(
      inputs.totalPriceExVat,
      inputs.batteryCostPrice,
      inputs.installerCut
    )
  }

  // LOGIC-07
  const paybackPeriod = calcPaybackPeriod(costAfterGronTeknik, totalAnnualSavings)

  // LOGIC-08
  const roi10Year = calcRoi10Year(costAfterGronTeknik, totalAnnualSavings)

  // LOGIC-09
  const roi15Year = calcRoi15Year(costAfterGronTeknik, totalAnnualSavings)

  const decimals = {
    effectiveCapacityPerCycleKwh: effectiveCapacity,
    energyFromBatteryPerYearKwh: annualEnergy,
    spotprisSavingsSek: spotprisSavings,
    effectTariffSavingsSek: effectTariffSavings,
    gridServicesIncomeSek: gridServicesIncome,
    totalAnnualSavingsSek: totalAnnualSavings,
    totalIncVatSek: totalIncVat,
    costAfterGronTeknikSek: costAfterGronTeknik,
    marginSek,
    paybackPeriodYears: paybackPeriod,
    roi10YearPercent: roi10Year,
    roi15YearPercent: roi15Year,
  }

  return {
    results: serializeResults(decimals),
    decimals,
  }
}

// Serialize Decimal results to numbers for JSON transport
export function serializeResults(decimals: {
  effectiveCapacityPerCycleKwh: Decimal
  energyFromBatteryPerYearKwh: Decimal
  spotprisSavingsSek: Decimal
  effectTariffSavingsSek: Decimal
  gridServicesIncomeSek: Decimal
  totalAnnualSavingsSek: Decimal
  totalIncVatSek: Decimal
  costAfterGronTeknikSek: Decimal
  marginSek?: Decimal
  paybackPeriodYears: Decimal
  roi10YearPercent: Decimal
  roi15YearPercent: Decimal
}): CalculationResults {
  return {
    effectiveCapacityPerCycleKwh: decimals.effectiveCapacityPerCycleKwh.toNumber(),
    energyFromBatteryPerYearKwh: decimals.energyFromBatteryPerYearKwh.toNumber(),
    spotprisSavingsSek: decimals.spotprisSavingsSek.toNumber(),
    effectTariffSavingsSek: decimals.effectTariffSavingsSek.toNumber(),
    gridServicesIncomeSek: decimals.gridServicesIncomeSek.toNumber(),
    totalAnnualSavingsSek: decimals.totalAnnualSavingsSek.toNumber(),
    totalIncVatSek: decimals.totalIncVatSek.toNumber(),
    costAfterGronTeknikSek: decimals.costAfterGronTeknikSek.toNumber(),
    marginSek: decimals.marginSek?.toNumber(),
    paybackPeriodYears: decimals.paybackPeriodYears.toNumber(),
    roi10YearPercent: decimals.roi10YearPercent.toNumber(),
    roi15YearPercent: decimals.roi15YearPercent.toNumber(),
  }
}
```
  </action>
  <verify>npm run build 2>&1 | head -50 (check for TypeScript errors in calculations module)</verify>
  <done>Calculation engine compiles and exports calculateBatteryROI function that implements LOGIC-01 through LOGIC-10 with decimal.js precision</done>
</task>

</tasks>

<verification>
1. Run `npx prisma validate` - schema is valid
2. Run `npx prisma generate` - client generates without errors
3. Run `npx tsc --noEmit` - all calculation modules compile
4. Verify decimal.js is in package.json dependencies
5. Verify permissions.ts includes CALCULATION_* permissions
</verification>

<success_criteria>
- Prisma schema includes Calculation and CalculationBattery models with all required fields
- Calculation engine implements all 10 LOGIC requirements
- All financial calculations use decimal.js (no floating point)
- Types, constants, presets, and elomrade lookup modules created
- Permissions added for calculation operations
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculator-engine/03-01-SUMMARY.md`
</output>
