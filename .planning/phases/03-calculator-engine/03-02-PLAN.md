---
phase: 03-calculator-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/calculation-wizard-store.ts
  - src/hooks/use-auto-save.ts
  - src/actions/calculations.ts
  - src/lib/db/tenant-client.ts
autonomous: true

must_haves:
  truths:
    - "Wizard state persists across browser refresh via localStorage"
    - "Changes auto-save to database every 2 seconds"
    - "Server actions create, update, and fetch calculations"
  artifacts:
    - path: "src/stores/calculation-wizard-store.ts"
      provides: "Zustand store with persist middleware"
      exports: ["useCalculationWizardStore"]
    - path: "src/hooks/use-auto-save.ts"
      provides: "Debounced auto-save hook"
      exports: ["useAutoSave"]
    - path: "src/actions/calculations.ts"
      provides: "Server actions for calculation CRUD"
      exports: ["saveDraft", "getCalculation", "listCalculations", "finalizeCalculation", "deleteCalculation"]
  key_links:
    - from: "src/hooks/use-auto-save.ts"
      to: "src/actions/calculations.ts"
      via: "saveDraft import"
      pattern: "import.*saveDraft.*from.*actions/calculations"
    - from: "src/stores/calculation-wizard-store.ts"
      to: "zustand"
      via: "persist middleware"
      pattern: "persist.*createJSONStorage"
---

<objective>
Create wizard state management with Zustand and debounced auto-save, plus server actions for calculation CRUD operations.

Purpose: Enables the multi-step wizard to maintain state across steps and persist data automatically - critical for user experience (no lost work).

Output: Zustand store with localStorage persistence, auto-save hook with 2-second debounce, and server actions for calculation CRUD.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calculator-engine/03-CONTEXT.md
@.planning/phases/03-calculator-engine/03-RESEARCH.md

# Existing patterns
@src/actions/batteries.ts
@src/lib/db/tenant-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Zustand wizard store</name>
  <files>src/stores/calculation-wizard-store.ts</files>
  <action>
First install required dependencies:
```bash
npm install zustand use-debounce
```

Create src/stores/calculation-wizard-store.ts:
```typescript
'use client'

import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import type { Elomrade, ConsumptionProfile } from '@/lib/calculations/types'
import { createEmptyProfile, applyPreset, SYSTEM_PRESETS } from '@/lib/calculations/presets'
import { DEFAULT_ANNUAL_CONSUMPTION_KWH } from '@/lib/calculations/constants'

interface BatterySelection {
  configId: string
  totalPriceExVat: number
  installationCost: number
}

interface WizardState {
  // Step tracking
  currentStep: number
  calculationId: string | null
  isDraft: boolean
  lastSavedAt: Date | null
  isSaving: boolean

  // Step 1: Customer Info
  customerName: string
  postalCode: string
  elomrade: Elomrade | null
  natagareId: string | null
  annualConsumptionKwh: number

  // Step 2: Consumption Profile
  consumptionProfile: ConsumptionProfile

  // Step 3: Battery Selection (supports multiple for comparison)
  batteries: BatterySelection[]

  // Actions
  setStep: (step: number) => void
  updateCustomerInfo: (data: Partial<{
    customerName: string
    postalCode: string
    elomrade: Elomrade | null
    natagareId: string | null
    annualConsumptionKwh: number
  }>) => void
  updateConsumptionHour: (month: number, hour: number, value: number) => void
  applyPresetToProfile: (presetId: string) => void
  copyMonthPattern: (fromMonth: number, toMonths: number[]) => void
  scaleProfileToAnnual: () => void
  addBattery: (battery: BatterySelection) => void
  removeBattery: (index: number) => void
  updateBatteryPricing: (index: number, data: Partial<{ totalPriceExVat: number; installationCost: number }>) => void
  markSaved: (calculationId: string) => void
  setSaving: (isSaving: boolean) => void
  loadFromServer: (data: {
    calculationId: string
    customerName: string
    postalCode: string | null
    elomrade: Elomrade
    natagareId: string
    annualConsumptionKwh: number
    consumptionProfile: ConsumptionProfile
    batteries: BatterySelection[]
  }) => void
  reset: () => void
}

function calculateProfileTotal(data: number[][]): number {
  return data.reduce((sum, month) => {
    const monthlyDaily = month.reduce((daySum, hour) => daySum + hour, 0)
    return sum + (monthlyDaily * 30) // Approximate 30 days per month
  }, 0)
}

const initialState = {
  currentStep: 0,
  calculationId: null,
  isDraft: true,
  lastSavedAt: null,
  isSaving: false,
  customerName: '',
  postalCode: '',
  elomrade: null as Elomrade | null,
  natagareId: null,
  annualConsumptionKwh: DEFAULT_ANNUAL_CONSUMPTION_KWH,
  consumptionProfile: { data: createEmptyProfile() },
  batteries: [] as BatterySelection[],
}

export const useCalculationWizardStore = create<WizardState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setStep: (step) => set({ currentStep: step }),

      updateCustomerInfo: (data) => set((state) => ({ ...state, ...data })),

      updateConsumptionHour: (month, hour, value) => set((state) => {
        const newData = state.consumptionProfile.data.map((m, mi) =>
          mi === month ? m.map((h, hi) => (hi === hour ? value : h)) : [...m]
        )
        return { consumptionProfile: { data: newData } }
      }),

      applyPresetToProfile: (presetId) => set((state) => {
        const preset = SYSTEM_PRESETS.find(p => p.id === presetId)
        if (!preset) return state
        const newProfile = applyPreset(preset, state.annualConsumptionKwh)
        return { consumptionProfile: { data: newProfile } }
      }),

      copyMonthPattern: (fromMonth, toMonths) => set((state) => {
        const sourcePattern = state.consumptionProfile.data[fromMonth]
        const newData = state.consumptionProfile.data.map((month, index) =>
          toMonths.includes(index) ? [...sourcePattern] : [...month]
        )
        return { consumptionProfile: { data: newData } }
      }),

      scaleProfileToAnnual: () => set((state) => {
        const currentTotal = calculateProfileTotal(state.consumptionProfile.data)
        if (currentTotal === 0) return state
        const scaleFactor = state.annualConsumptionKwh / currentTotal
        const scaledData = state.consumptionProfile.data.map(month =>
          month.map(hour => hour * scaleFactor)
        )
        return { consumptionProfile: { data: scaledData } }
      }),

      addBattery: (battery) => set((state) => ({
        batteries: [...state.batteries, battery]
      })),

      removeBattery: (index) => set((state) => ({
        batteries: state.batteries.filter((_, i) => i !== index)
      })),

      updateBatteryPricing: (index, data) => set((state) => ({
        batteries: state.batteries.map((b, i) =>
          i === index ? { ...b, ...data } : b
        )
      })),

      markSaved: (calculationId) => set({
        calculationId,
        lastSavedAt: new Date(),
        isSaving: false,
      }),

      setSaving: (isSaving) => set({ isSaving }),

      loadFromServer: (data) => set({
        calculationId: data.calculationId,
        customerName: data.customerName,
        postalCode: data.postalCode || '',
        elomrade: data.elomrade,
        natagareId: data.natagareId,
        annualConsumptionKwh: data.annualConsumptionKwh,
        consumptionProfile: data.consumptionProfile,
        batteries: data.batteries,
        isDraft: true,
        lastSavedAt: new Date(),
      }),

      reset: () => set({
        ...initialState,
        consumptionProfile: { data: createEmptyProfile() },
      }),
    }),
    {
      name: 'kalkyla-wizard-draft',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        // Only persist form data, not UI state
        calculationId: state.calculationId,
        customerName: state.customerName,
        postalCode: state.postalCode,
        elomrade: state.elomrade,
        natagareId: state.natagareId,
        annualConsumptionKwh: state.annualConsumptionKwh,
        consumptionProfile: state.consumptionProfile,
        batteries: state.batteries,
        currentStep: state.currentStep,
      }),
    }
  )
)
```
  </action>
  <verify>npx tsc --noEmit src/stores/calculation-wizard-store.ts</verify>
  <done>Zustand store compiles and exports useCalculationWizardStore with all wizard state and actions</done>
</task>

<task type="auto">
  <name>Task 2: Create server actions for calculation CRUD</name>
  <files>src/actions/calculations.ts, src/lib/db/tenant-client.ts</files>
  <action>
First update src/lib/db/tenant-client.ts to add calculation scoping (add to the existing extensions):

Add to the model extensions:
```typescript
calculation: {
  async findMany({ args, query }: { args: any; query: any }) {
    args.where = { ...args.where, orgId }
    return query(args)
  },
  async findUnique({ args, query }: { args: any; query: any }) {
    const result = await query(args)
    if (result && result.orgId !== orgId) return null
    return result
  },
  async findFirst({ args, query }: { args: any; query: any }) {
    args.where = { ...args.where, orgId }
    return query(args)
  },
  async create({ args, query }: { args: any; query: any }) {
    args.data = { ...args.data, orgId }
    return query(args)
  },
  async update({ args, query }: { args: any; query: any }) {
    const existing = await prisma.calculation.findUnique({
      where: args.where,
      select: { orgId: true },
    })
    if (!existing || existing.orgId !== orgId) {
      throw new Error('Not authorized')
    }
    return query(args)
  },
  async delete({ args, query }: { args: any; query: any }) {
    const existing = await prisma.calculation.findUnique({
      where: args.where,
      select: { orgId: true },
    })
    if (!existing || existing.orgId !== orgId) {
      throw new Error('Not authorized')
    }
    return query(args)
  },
},
```

Create src/actions/calculations.ts:
```typescript
'use server'

import { auth } from '@/lib/auth/auth'
import { hasPermission } from '@/lib/auth/permissions'
import { prisma } from '@/lib/db/client'
import { createTenantClient } from '@/lib/db/tenant-client'
import { z } from 'zod'
import type { ConsumptionProfile, Elomrade } from '@/lib/calculations/types'

const saveDraftSchema = z.object({
  calculationId: z.string().nullable(),
  customerName: z.string().min(1, 'Kundnamn kravs'),
  postalCode: z.string().optional(),
  elomrade: z.enum(['SE1', 'SE2', 'SE3', 'SE4']),
  natagareId: z.string().min(1, 'Natagare kravs'),
  annualConsumptionKwh: z.number().min(1),
  consumptionProfile: z.object({
    data: z.array(z.array(z.number())),
  }),
  batteries: z.array(z.object({
    configId: z.string(),
    totalPriceExVat: z.number(),
    installationCost: z.number(),
  })),
})

export type SaveDraftInput = z.infer<typeof saveDraftSchema>

export async function saveDraft(input: SaveDraftInput) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'Unauthorized' }
  }

  if (!hasPermission(session.user.role, 'CALCULATION_CREATE')) {
    return { error: 'Forbidden' }
  }

  const parsed = saveDraftSchema.safeParse(input)
  if (!parsed.success) {
    return { error: parsed.error.issues[0].message }
  }

  const data = parsed.data
  const tenantClient = createTenantClient(session.user.orgId!)

  try {
    if (data.calculationId) {
      // Update existing draft
      const updated = await tenantClient.calculation.update({
        where: { id: data.calculationId },
        data: {
          customerName: data.customerName,
          postalCode: data.postalCode || null,
          elomrade: data.elomrade as Elomrade,
          natagareId: data.natagareId,
          annualConsumptionKwh: data.annualConsumptionKwh,
          consumptionProfile: data.consumptionProfile as any,
        },
      })

      // Sync batteries (delete all and recreate for simplicity)
      await prisma.calculationBattery.deleteMany({
        where: { calculationId: data.calculationId },
      })

      if (data.batteries.length > 0) {
        await prisma.calculationBattery.createMany({
          data: data.batteries.map((b, i) => ({
            calculationId: data.calculationId!,
            batteryConfigId: b.configId,
            totalPriceExVat: b.totalPriceExVat,
            installationCost: b.installationCost,
            sortOrder: i,
          })),
        })
      }

      return { calculationId: updated.id }
    } else {
      // Create new draft
      const created = await (tenantClient.calculation.create as any)({
        data: {
          customerName: data.customerName,
          postalCode: data.postalCode || null,
          elomrade: data.elomrade as Elomrade,
          natagareId: data.natagareId,
          annualConsumptionKwh: data.annualConsumptionKwh,
          consumptionProfile: data.consumptionProfile,
          createdBy: session.user.id,
          status: 'DRAFT',
        } as any,
      })

      if (data.batteries.length > 0) {
        await prisma.calculationBattery.createMany({
          data: data.batteries.map((b, i) => ({
            calculationId: created.id,
            batteryConfigId: b.configId,
            totalPriceExVat: b.totalPriceExVat,
            installationCost: b.installationCost,
            sortOrder: i,
          })),
        })
      }

      return { calculationId: created.id }
    }
  } catch (error) {
    console.error('Save draft error:', error)
    return { error: 'Kunde inte spara utkastet' }
  }
}

export async function getCalculation(id: string) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'Unauthorized' }
  }

  if (!hasPermission(session.user.role, 'CALCULATION_VIEW')) {
    return { error: 'Forbidden' }
  }

  try {
    let calculation

    if (session.user.role === 'SUPER_ADMIN') {
      calculation = await prisma.calculation.findUnique({
        where: { id },
        include: {
          natagare: true,
          batteries: {
            include: { batteryConfig: { include: { brand: true } } },
            orderBy: { sortOrder: 'asc' },
          },
          organization: true,
        },
      })
    } else {
      const tenantClient = createTenantClient(session.user.orgId!)
      calculation = await tenantClient.calculation.findUnique({
        where: { id },
        include: {
          natagare: true,
          batteries: {
            include: { batteryConfig: { include: { brand: true } } },
            orderBy: { sortOrder: 'asc' },
          },
        },
      })
    }

    if (!calculation) {
      return { error: 'Kalkyl hittades inte' }
    }

    // Check ownership for Closer role
    if (session.user.role === 'CLOSER' && calculation.createdBy !== session.user.id) {
      return { error: 'Forbidden' }
    }

    // Serialize Decimal fields
    return {
      calculation: {
        ...calculation,
        annualConsumptionKwh: Number(calculation.annualConsumptionKwh),
        batteries: calculation.batteries.map(b => ({
          ...b,
          totalPriceExVat: Number(b.totalPriceExVat),
          installationCost: Number(b.installationCost),
          batteryConfig: {
            ...b.batteryConfig,
            capacityKwh: Number(b.batteryConfig.capacityKwh),
            maxDischargeKw: Number(b.batteryConfig.maxDischargeKw),
            maxChargeKw: Number(b.batteryConfig.maxChargeKw),
            chargeEfficiency: Number(b.batteryConfig.chargeEfficiency),
            dischargeEfficiency: Number(b.batteryConfig.dischargeEfficiency),
            warrantyYears: b.batteryConfig.warrantyYears,
            guaranteedCycles: b.batteryConfig.guaranteedCycles,
            degradationPerYear: Number(b.batteryConfig.degradationPerYear),
            costPrice: Number(b.batteryConfig.costPrice),
          },
        })),
        natagare: {
          ...calculation.natagare,
          dayRateSekKw: Number(calculation.natagare.dayRateSekKw),
          nightRateSekKw: Number(calculation.natagare.nightRateSekKw),
        },
      },
    }
  } catch (error) {
    console.error('Get calculation error:', error)
    return { error: 'Kunde inte hamta kalkyl' }
  }
}

export async function listCalculations() {
  const session = await auth()
  if (!session?.user) {
    return { error: 'Unauthorized' }
  }

  if (!hasPermission(session.user.role, 'CALCULATION_VIEW')) {
    return { error: 'Forbidden' }
  }

  try {
    let calculations

    if (session.user.role === 'SUPER_ADMIN') {
      calculations = await prisma.calculation.findMany({
        orderBy: { updatedAt: 'desc' },
        include: {
          organization: { select: { name: true } },
          batteries: {
            include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
            orderBy: { sortOrder: 'asc' },
            take: 1, // Just get first battery for list display
          },
        },
      })
    } else if (session.user.role === 'ORG_ADMIN') {
      const tenantClient = createTenantClient(session.user.orgId!)
      calculations = await tenantClient.calculation.findMany({
        orderBy: { updatedAt: 'desc' },
        include: {
          batteries: {
            include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
            orderBy: { sortOrder: 'asc' },
            take: 1,
          },
        },
      })
    } else {
      // CLOSER - only own calculations
      const tenantClient = createTenantClient(session.user.orgId!)
      calculations = await tenantClient.calculation.findMany({
        where: { createdBy: session.user.id },
        orderBy: { updatedAt: 'desc' },
        include: {
          batteries: {
            include: { batteryConfig: { select: { name: true, brand: { select: { name: true } } } } },
            orderBy: { sortOrder: 'asc' },
            take: 1,
          },
        },
      })
    }

    return {
      calculations: calculations.map(c => ({
        id: c.id,
        customerName: c.customerName,
        elomrade: c.elomrade,
        status: c.status,
        createdAt: c.createdAt,
        updatedAt: c.updatedAt,
        batteryName: c.batteries[0]
          ? `${c.batteries[0].batteryConfig.brand.name} ${c.batteries[0].batteryConfig.name}`
          : null,
        organizationName: 'organization' in c ? (c as any).organization?.name : undefined,
      })),
    }
  } catch (error) {
    console.error('List calculations error:', error)
    return { error: 'Kunde inte hamta kalkyler' }
  }
}

export async function finalizeCalculation(id: string, results: any) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'Unauthorized' }
  }

  if (!hasPermission(session.user.role, 'CALCULATION_FINALIZE')) {
    return { error: 'Forbidden' }
  }

  try {
    const tenantClient = session.user.role === 'SUPER_ADMIN'
      ? prisma
      : createTenantClient(session.user.orgId!)

    // Check ownership for Closer
    if (session.user.role === 'CLOSER') {
      const existing = await tenantClient.calculation.findUnique({
        where: { id },
        select: { createdBy: true },
      })
      if (!existing || existing.createdBy !== session.user.id) {
        return { error: 'Forbidden' }
      }
    }

    await tenantClient.calculation.update({
      where: { id },
      data: {
        status: 'COMPLETE',
        results: results,
        finalizedAt: new Date(),
      },
    })

    return { success: true }
  } catch (error) {
    console.error('Finalize calculation error:', error)
    return { error: 'Kunde inte slutfora kalkyl' }
  }
}

export async function deleteCalculation(id: string) {
  const session = await auth()
  if (!session?.user) {
    return { error: 'Unauthorized' }
  }

  if (!hasPermission(session.user.role, 'CALCULATION_DELETE')) {
    return { error: 'Forbidden' }
  }

  try {
    const tenantClient = session.user.role === 'SUPER_ADMIN'
      ? prisma
      : createTenantClient(session.user.orgId!)

    // Check ownership for Closer
    if (session.user.role === 'CLOSER') {
      const existing = await tenantClient.calculation.findUnique({
        where: { id },
        select: { createdBy: true },
      })
      if (!existing || existing.createdBy !== session.user.id) {
        return { error: 'Forbidden' }
      }
    }

    // Soft delete (archive)
    await tenantClient.calculation.update({
      where: { id },
      data: { status: 'ARCHIVED' },
    })

    return { success: true }
  } catch (error) {
    console.error('Delete calculation error:', error)
    return { error: 'Kunde inte ta bort kalkyl' }
  }
}
```
  </action>
  <verify>npx tsc --noEmit src/actions/calculations.ts</verify>
  <done>Server actions compile and provide saveDraft, getCalculation, listCalculations, finalizeCalculation, deleteCalculation</done>
</task>

<task type="auto">
  <name>Task 3: Create auto-save hook with debounce</name>
  <files>src/hooks/use-auto-save.ts</files>
  <action>
Create src/hooks/use-auto-save.ts:
```typescript
'use client'

import { useEffect, useRef, useCallback } from 'react'
import { useDebouncedCallback } from 'use-debounce'
import { useCalculationWizardStore } from '@/stores/calculation-wizard-store'
import { saveDraft } from '@/actions/calculations'

export function useAutoSave() {
  const {
    calculationId,
    customerName,
    postalCode,
    elomrade,
    natagareId,
    annualConsumptionKwh,
    consumptionProfile,
    batteries,
    lastSavedAt,
    markSaved,
    setSaving,
  } = useCalculationWizardStore()

  const isFirstRender = useRef(true)
  const lastSaveAttempt = useRef<string>('')

  const performSave = useCallback(async () => {
    // Don't save if missing required fields
    if (!customerName || !elomrade || !natagareId) {
      return
    }

    // Create a hash of current state to avoid duplicate saves
    const stateHash = JSON.stringify({
      calculationId,
      customerName,
      postalCode,
      elomrade,
      natagareId,
      annualConsumptionKwh,
      consumptionProfile,
      batteries,
    })

    // Skip if state hasn't changed since last save
    if (stateHash === lastSaveAttempt.current) {
      return
    }

    lastSaveAttempt.current = stateHash
    setSaving(true)

    try {
      const result = await saveDraft({
        calculationId,
        customerName,
        postalCode: postalCode || undefined,
        elomrade,
        natagareId,
        annualConsumptionKwh,
        consumptionProfile,
        batteries: batteries.map(b => ({
          configId: b.configId,
          totalPriceExVat: b.totalPriceExVat,
          installationCost: b.installationCost,
        })),
      })

      if (result.calculationId) {
        markSaved(result.calculationId)
      } else if (result.error) {
        console.error('Auto-save error:', result.error)
        setSaving(false)
      }
    } catch (error) {
      console.error('Auto-save failed:', error)
      setSaving(false)
    }
  }, [
    calculationId,
    customerName,
    postalCode,
    elomrade,
    natagareId,
    annualConsumptionKwh,
    consumptionProfile,
    batteries,
    markSaved,
    setSaving,
  ])

  const debouncedSave = useDebouncedCallback(performSave, 2000)

  // Watch for changes and trigger debounced save
  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false
      return
    }
    debouncedSave()
  }, [
    customerName,
    postalCode,
    elomrade,
    natagareId,
    annualConsumptionKwh,
    consumptionProfile,
    batteries,
    debouncedSave,
  ])

  // Force save on unmount
  useEffect(() => {
    return () => {
      debouncedSave.flush()
    }
  }, [debouncedSave])

  return {
    lastSavedAt,
    isSaving: useCalculationWizardStore(state => state.isSaving),
    saveNow: performSave,
  }
}
```
  </action>
  <verify>npx tsc --noEmit src/hooks/use-auto-save.ts</verify>
  <done>Auto-save hook compiles and exports useAutoSave with 2-second debounce, state deduplication, and flush on unmount</done>
</task>

</tasks>

<verification>
1. Run `npm ls zustand use-debounce` - both packages installed
2. Run `npx tsc --noEmit` - no TypeScript errors
3. Verify Zustand store exports useCalculationWizardStore
4. Verify server actions export all CRUD functions
5. Verify auto-save hook debounces at 2 seconds
</verification>

<success_criteria>
- Zustand store persists wizard state to localStorage
- Auto-save hook debounces changes and calls saveDraft every 2 seconds
- Server actions handle CRUD with proper auth and tenant scoping
- Closer can only see/edit own calculations
- Org Admin can see/edit all org calculations
- Super Admin can see all calculations
</success_criteria>

<output>
After completion, create `.planning/phases/03-calculator-engine/03-02-SUMMARY.md`
</output>
