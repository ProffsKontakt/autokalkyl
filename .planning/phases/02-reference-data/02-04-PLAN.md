---
phase: 02-reference-data
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/electricity/types.ts
  - src/lib/electricity/fetch-prices.ts
  - src/lib/electricity/quarterly-averages.ts
  - src/actions/electricity.ts
  - src/app/(dashboard)/dashboard/electricity/page.tsx
  - src/components/electricity/quarterly-prices.tsx
autonomous: true

must_haves:
  truths:
    - "System can fetch electricity prices from mgrey.se API"
    - "Prices are stored with date, hour, and elomrade granularity"
    - "Quarterly averages are calculated with day/night split"
    - "Closer can view quarterly average prices when creating calculations"
    - "Super Admin can trigger manual price fetch"
  artifacts:
    - path: "src/lib/electricity/fetch-prices.ts"
      provides: "API fetching and storage logic"
      exports: ["fetchAndStorePrices", "fetchPricesForDateRange"]
    - path: "src/lib/electricity/quarterly-averages.ts"
      provides: "Quarterly average calculation"
      exports: ["calculateQuarterlyAverages", "getQuarterlyAveragesForElomrade"]
    - path: "src/components/electricity/quarterly-prices.tsx"
      provides: "Display component for quarterly prices"
      min_lines: 30
  key_links:
    - from: "src/lib/electricity/fetch-prices.ts"
      to: "https://mgrey.se/espot"
      via: "fetch API call"
      pattern: "mgrey\\.se/espot"
    - from: "src/components/electricity/quarterly-prices.tsx"
      to: "src/actions/electricity.ts"
      via: "getQuarterlyPrices action"
      pattern: "getQuarterlyPrices"
---

<objective>
Implement electricity pricing storage, API fetching, and quarterly average display.

Purpose: Closers need to see quarterly average electricity prices when creating calculations to estimate ROI accurately. This covers requirements ELEC-01 through ELEC-05.

Output: Electricity price fetching from mgrey.se, database storage, quarterly average calculation, and display components.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-reference-data/02-RESEARCH.md
@.planning/phases/02-reference-data/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create electricity price fetching and storage utilities</name>
  <files>src/lib/electricity/types.ts, src/lib/electricity/fetch-prices.ts</files>
  <action>
Create electricity price utilities:

**src/lib/electricity/types.ts:**
```typescript
import { Elomrade } from '@prisma/client';

export interface MgreyPrice {
  hour: number;
  price_sek: number; // Actually ore/kWh despite name
  price_eur: number;
  kmeans: number;
}

export interface MgreyResponse {
  date: string;
  SE1: MgreyPrice[];
  SE2: MgreyPrice[];
  SE3: MgreyPrice[];
  SE4: MgreyPrice[];
}

export const ELOMRADE_NAMES: Record<Elomrade, string> = {
  SE1: 'Norra Sverige (Lulea)',
  SE2: 'Mellersta norra Sverige (Sundsvall)',
  SE3: 'Mellersta sodra Sverige (Stockholm)',
  SE4: 'Sodra Sverige (Malmo)',
};

// Price conversion helpers
export const priceConversion = {
  // mgrey.se returns ore/kWh, store as-is
  oreToSekKwh: (ore: number) => ore / 100,
  sekKwhToOre: (sek: number) => sek * 100,
};
```

**src/lib/electricity/fetch-prices.ts:**
```typescript
import { prisma } from '@/lib/db/client';
import { Elomrade } from '@prisma/client';
import { MgreyResponse } from './types';

const MGREY_API_URL = 'https://mgrey.se/espot';

/**
 * Fetch electricity prices for a specific date from mgrey.se API.
 * Stores prices in the database (upserts to handle re-runs).
 *
 * @param date - Date to fetch prices for
 * @returns Number of price records stored
 */
export async function fetchAndStorePrices(date: Date): Promise<{ success: boolean; count?: number; error?: string }> {
  const dateStr = date.toISOString().split('T')[0];

  try {
    const response = await fetch(`${MGREY_API_URL}?format=json&date=${dateStr}`, {
      next: { revalidate: 3600 }, // Cache for 1 hour
    });

    if (!response.ok) {
      return { success: false, error: `API error: ${response.status}` };
    }

    const data: MgreyResponse = await response.json();

    // Check if data has expected structure
    if (!data.SE1 || !Array.isArray(data.SE1)) {
      return { success: false, error: 'Invalid API response format' };
    }

    const areas: Elomrade[] = ['SE1', 'SE2', 'SE3', 'SE4'];
    const records = areas.flatMap(area =>
      data[area].map(price => ({
        elomrade: area,
        date: new Date(data.date),
        hour: price.hour,
        priceOre: price.price_sek, // mgrey.se returns ore/kWh despite "price_sek" name
      }))
    );

    // Upsert all records in a transaction
    await prisma.$transaction(
      records.map(record =>
        prisma.electricityPrice.upsert({
          where: {
            elomrade_date_hour: {
              elomrade: record.elomrade,
              date: record.date,
              hour: record.hour,
            },
          },
          update: { priceOre: record.priceOre },
          create: record,
        })
      )
    );

    return { success: true, count: records.length };
  } catch (error) {
    console.error('Failed to fetch electricity prices:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

/**
 * Fetch prices for a date range (backfill).
 * Fetches one day at a time with a small delay to be respectful to the API.
 */
export async function fetchPricesForDateRange(
  startDate: Date,
  endDate: Date,
  onProgress?: (date: Date, result: { success: boolean; count?: number; error?: string }) => void
): Promise<{ totalDays: number; successfulDays: number; totalRecords: number }> {
  const results = {
    totalDays: 0,
    successfulDays: 0,
    totalRecords: 0,
  };

  const current = new Date(startDate);
  while (current <= endDate) {
    results.totalDays++;

    const result = await fetchAndStorePrices(new Date(current));

    if (result.success) {
      results.successfulDays++;
      results.totalRecords += result.count || 0;
    }

    if (onProgress) {
      onProgress(new Date(current), result);
    }

    // Move to next day
    current.setDate(current.getDate() + 1);

    // Small delay to be respectful to the API (100ms)
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  return results;
}

/**
 * Get stored prices for a specific date and elomrade.
 */
export async function getStoredPrices(elomrade: Elomrade, date: Date) {
  return prisma.electricityPrice.findMany({
    where: {
      elomrade,
      date,
    },
    orderBy: { hour: 'asc' },
  });
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/lib/electricity/*.ts` - no type errors</verify>
  <done>Electricity price fetching and storage utilities created with mgrey.se API integration</done>
</task>

<task type="auto">
  <name>Task 2: Create quarterly average calculation and server actions</name>
  <files>src/lib/electricity/quarterly-averages.ts, src/actions/electricity.ts</files>
  <action>
Create quarterly average calculation and server actions:

**src/lib/electricity/quarterly-averages.ts:**
```typescript
import { prisma } from '@/lib/db/client';
import { Elomrade } from '@prisma/client';

/**
 * Calculate quarterly averages from hourly price data.
 * Day hours: 06:00-21:59 (hours 6-21)
 * Night hours: 22:00-05:59 (hours 22-23, 0-5)
 */
export async function calculateQuarterlyAverages(
  elomrade: Elomrade,
  year: number,
  quarter: number
): Promise<{ success: boolean; error?: string }> {
  // Calculate date range for quarter
  const startMonth = (quarter - 1) * 3; // Q1=0, Q2=3, Q3=6, Q4=9
  const startDate = new Date(year, startMonth, 1);
  const endDate = new Date(year, startMonth + 3, 0); // Last day of quarter

  const prices = await prisma.electricityPrice.findMany({
    where: {
      elomrade,
      date: {
        gte: startDate,
        lte: endDate,
      },
    },
  });

  if (prices.length === 0) {
    return { success: false, error: 'No price data for this period' };
  }

  // Split into day (6-21) and night (22-23, 0-5) hours
  const dayPrices = prices.filter(p => p.hour >= 6 && p.hour < 22);
  const nightPrices = prices.filter(p => p.hour < 6 || p.hour >= 22);

  const avg = (arr: typeof prices) =>
    arr.length > 0
      ? arr.reduce((sum, p) => sum + Number(p.priceOre), 0) / arr.length
      : 0;

  const avgDayPriceOre = avg(dayPrices);
  const avgNightPriceOre = avg(nightPrices);
  const avgPriceOre = avg(prices);

  await prisma.electricityPriceQuarterly.upsert({
    where: {
      elomrade_year_quarter: { elomrade, year, quarter },
    },
    update: {
      avgDayPriceOre,
      avgNightPriceOre,
      avgPriceOre,
    },
    create: {
      elomrade,
      year,
      quarter,
      avgDayPriceOre,
      avgNightPriceOre,
      avgPriceOre,
    },
  });

  return { success: true };
}

/**
 * Get quarterly averages for display.
 * Returns last 4 quarters for a given elomrade.
 */
export async function getQuarterlyAveragesForElomrade(elomrade: Elomrade, count = 4) {
  return prisma.electricityPriceQuarterly.findMany({
    where: { elomrade },
    orderBy: [{ year: 'desc' }, { quarter: 'desc' }],
    take: count,
  });
}

/**
 * Get all quarterly averages for all elomraden.
 * Returns most recent quarter's data for each area.
 */
export async function getLatestQuarterlyAverages() {
  const areas: Elomrade[] = ['SE1', 'SE2', 'SE3', 'SE4'];
  const results: Record<Elomrade, { avgDayPriceOre: number; avgNightPriceOre: number; avgPriceOre: number; year: number; quarter: number } | null> = {
    SE1: null,
    SE2: null,
    SE3: null,
    SE4: null,
  };

  for (const area of areas) {
    const latest = await prisma.electricityPriceQuarterly.findFirst({
      where: { elomrade: area },
      orderBy: [{ year: 'desc' }, { quarter: 'desc' }],
    });
    if (latest) {
      results[area] = {
        avgDayPriceOre: Number(latest.avgDayPriceOre),
        avgNightPriceOre: Number(latest.avgNightPriceOre),
        avgPriceOre: Number(latest.avgPriceOre),
        year: latest.year,
        quarter: latest.quarter,
      };
    }
  }

  return results;
}
```

**src/actions/electricity.ts:**
```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { auth } from '@/lib/auth/auth';
import { hasPermission, PERMISSIONS, Role } from '@/lib/auth/permissions';
import { fetchAndStorePrices, fetchPricesForDateRange } from '@/lib/electricity/fetch-prices';
import { calculateQuarterlyAverages, getLatestQuarterlyAverages, getQuarterlyAveragesForElomrade } from '@/lib/electricity/quarterly-averages';
import { Elomrade } from '@prisma/client';

/**
 * Get quarterly prices for display in calculation builder.
 * Requires ELPRICES_VIEW permission.
 */
export async function getQuarterlyPrices() {
  const session = await auth();
  if (!session?.user) {
    return { error: 'Ej inloggad' };
  }

  const role = session.user.role as Role;
  if (!hasPermission(role, PERMISSIONS.ELPRICES_VIEW)) {
    return { error: 'Du har inte behorighet' };
  }

  try {
    const prices = await getLatestQuarterlyAverages();
    return { prices };
  } catch (error) {
    console.error('Failed to get quarterly prices:', error);
    return { error: 'Kunde inte hamta elpriser' };
  }
}

/**
 * Get historical quarterly prices for a specific elomrade.
 */
export async function getQuarterlyPricesForArea(elomrade: Elomrade, count = 8) {
  const session = await auth();
  if (!session?.user) {
    return { error: 'Ej inloggad' };
  }

  const role = session.user.role as Role;
  if (!hasPermission(role, PERMISSIONS.ELPRICES_VIEW)) {
    return { error: 'Du har inte behorighet' };
  }

  try {
    const prices = await getQuarterlyAveragesForElomrade(elomrade, count);
    return { prices: prices.map(p => ({
      year: p.year,
      quarter: p.quarter,
      avgDayPriceOre: Number(p.avgDayPriceOre),
      avgNightPriceOre: Number(p.avgNightPriceOre),
      avgPriceOre: Number(p.avgPriceOre),
    })) };
  } catch (error) {
    console.error('Failed to get quarterly prices:', error);
    return { error: 'Kunde inte hamta elpriser' };
  }
}

/**
 * Fetch prices for today (can be called by automated job).
 * Requires ELPRICES_MANAGE permission.
 */
export async function fetchTodaysPrices() {
  const session = await auth();
  if (!session?.user) {
    return { error: 'Ej inloggad' };
  }

  const role = session.user.role as Role;
  if (!hasPermission(role, PERMISSIONS.ELPRICES_MANAGE)) {
    return { error: 'Du har inte behorighet' };
  }

  const result = await fetchAndStorePrices(new Date());

  if (result.success) {
    revalidatePath('/dashboard/electricity');
    return { success: true, count: result.count };
  }

  return { error: result.error || 'Kunde inte hamta elpriser' };
}

/**
 * Recalculate quarterly averages for current quarter.
 * Requires ELPRICES_MANAGE permission.
 */
export async function recalculateQuarterlyAverages() {
  const session = await auth();
  if (!session?.user) {
    return { error: 'Ej inloggad' };
  }

  const role = session.user.role as Role;
  if (!hasPermission(role, PERMISSIONS.ELPRICES_MANAGE)) {
    return { error: 'Du har inte behorighet' };
  }

  const now = new Date();
  const year = now.getFullYear();
  const quarter = Math.floor(now.getMonth() / 3) + 1;

  const areas: Elomrade[] = ['SE1', 'SE2', 'SE3', 'SE4'];
  const results = [];

  for (const area of areas) {
    const result = await calculateQuarterlyAverages(area, year, quarter);
    results.push({ area, ...result });
  }

  revalidatePath('/dashboard/electricity');

  const failures = results.filter(r => !r.success);
  if (failures.length > 0) {
    return { error: `Misslyckades for: ${failures.map(f => f.area).join(', ')}` };
  }

  return { success: true };
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/lib/electricity/*.ts src/actions/electricity.ts` - no type errors</verify>
  <done>Quarterly average calculation and server actions created with proper permissions</done>
</task>

<task type="auto">
  <name>Task 3: Create electricity price display component and page</name>
  <files>src/components/electricity/quarterly-prices.tsx, src/app/(dashboard)/dashboard/electricity/page.tsx</files>
  <action>
Create electricity price display components:

**src/components/electricity/quarterly-prices.tsx:**
```typescript
'use client';

import { Card } from '@/components/ui/card';
import { ELOMRADE_NAMES, priceConversion } from '@/lib/electricity/types';
import { Elomrade } from '@prisma/client';

interface QuarterlyPricesProps {
  prices: Record<Elomrade, {
    avgDayPriceOre: number;
    avgNightPriceOre: number;
    avgPriceOre: number;
    year: number;
    quarter: number;
  } | null>;
}

export function QuarterlyPrices({ prices }: QuarterlyPricesProps) {
  const areas: Elomrade[] = ['SE1', 'SE2', 'SE3', 'SE4'];

  const formatPrice = (ore: number) => {
    const sek = priceConversion.oreToSekKwh(ore);
    return `${sek.toFixed(2)} SEK/kWh`;
  };

  const formatQuarter = (year: number, quarter: number) => {
    return `Q${quarter} ${year}`;
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {areas.map(area => {
        const data = prices[area];

        return (
          <Card key={area} className="p-4">
            <h3 className="font-semibold text-lg">{area}</h3>
            <p className="text-sm text-gray-600 mb-3">{ELOMRADE_NAMES[area]}</p>

            {data ? (
              <>
                <p className="text-xs text-gray-500 mb-2">
                  {formatQuarter(data.year, data.quarter)}
                </p>
                <div className="space-y-1">
                  <div className="flex justify-between">
                    <span className="text-sm">Dag (06-22):</span>
                    <span className="font-medium">{formatPrice(data.avgDayPriceOre)}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-sm">Natt (22-06):</span>
                    <span className="font-medium">{formatPrice(data.avgNightPriceOre)}</span>
                  </div>
                  <div className="flex justify-between border-t pt-1 mt-1">
                    <span className="text-sm">Genomsnitt:</span>
                    <span className="font-medium">{formatPrice(data.avgPriceOre)}</span>
                  </div>
                </div>
              </>
            ) : (
              <p className="text-sm text-gray-400">Ingen data tillganglig</p>
            )}
          </Card>
        );
      })}
    </div>
  );
}
```

**src/app/(dashboard)/dashboard/electricity/page.tsx:**
```typescript
import { auth } from '@/lib/auth/auth';
import { redirect } from 'next/navigation';
import { getQuarterlyPrices, fetchTodaysPrices, recalculateQuarterlyAverages } from '@/actions/electricity';
import { QuarterlyPrices } from '@/components/electricity/quarterly-prices';
import { hasPermission, PERMISSIONS, Role } from '@/lib/auth/permissions';
import { Button } from '@/components/ui/button';
import { revalidatePath } from 'next/cache';

export default async function ElectricityPage() {
  const session = await auth();
  if (!session?.user) redirect('/login');

  const role = session.user.role as Role;
  if (!hasPermission(role, PERMISSIONS.ELPRICES_VIEW)) {
    redirect('/dashboard');
  }

  const { prices, error } = await getQuarterlyPrices();
  const canManage = hasPermission(role, PERMISSIONS.ELPRICES_MANAGE);

  return (
    <div>
      <header className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold">Elpriser</h1>
          <p className="text-gray-600">Kvartalsgenomsnitt per elomrade</p>
        </div>
        {canManage && (
          <div className="flex gap-2">
            <form action={async () => {
              'use server';
              await fetchTodaysPrices();
              revalidatePath('/dashboard/electricity');
            }}>
              <Button type="submit" variant="outline">
                Hamta dagens priser
              </Button>
            </form>
            <form action={async () => {
              'use server';
              await recalculateQuarterlyAverages();
              revalidatePath('/dashboard/electricity');
            }}>
              <Button type="submit" variant="outline">
                Rakna om kvartal
              </Button>
            </form>
          </div>
        )}
      </header>

      {error ? (
        <div className="text-red-600">Fel: {error}</div>
      ) : (
        <>
          <QuarterlyPrices prices={prices!} />
          <div className="mt-6 text-sm text-gray-500">
            <p>Priser hamtas fran Nord Pool via mgrey.se.</p>
            <p>Dag = 06:00-22:00, Natt = 22:00-06:00</p>
          </div>
        </>
      )}
    </div>
  );
}
```

Note: The page uses server actions inline for the refresh buttons. Super Admin only sees these buttons (ELPRICES_MANAGE permission).
  </action>
  <verify>Run `npm run build` - build should succeed with no errors</verify>
  <done>Electricity price display component and page created with quarterly averages and admin controls</done>
</task>

</tasks>

<verification>
1. Start dev server: `npm run dev`
2. Log in as Super Admin
3. Navigate to /dashboard/electricity
4. Click "Hamta dagens priser" - should fetch from mgrey.se
5. Click "Rakna om kvartal" - should calculate averages
6. Verify quarterly prices display for SE1-SE4
7. Log in as Closer - verify can view prices but no admin buttons shown

Manual API test:
```bash
# Test mgrey.se API directly
curl -s "https://mgrey.se/espot?format=json&date=2025-01-15" | jq '.SE3[0:3]'
```

Database verification:
```bash
npx prisma studio
# Check ElectricityPrice table has hourly records
# Check ElectricityPriceQuarterly table has averages
```
</verification>

<success_criteria>
1. ELEC-01: System stores electricity prices per elomrade (SE1-SE4)
2. ELEC-02: Prices stored with date and hour granularity
3. ELEC-03: System can fetch prices from mgrey.se API (manual fetch fallback via admin UI)
4. ELEC-04: Closer sees quarterly average prices (day/night split shown)
5. ELEC-05: Quarterly averages stored for use in calculations
6. Super Admin can trigger price fetch and recalculation
7. Prices display in SEK/kWh with day/night split (converted from ore)
8. All elomraden shown with human-readable names
9. Permission checks enforced (ELPRICES_VIEW, ELPRICES_MANAGE)
</success_criteria>

<output>
After completion, create `.planning/phases/02-reference-data/02-04-SUMMARY.md`
</output>
