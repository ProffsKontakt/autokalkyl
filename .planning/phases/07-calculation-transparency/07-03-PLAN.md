---
phase: 07-calculation-transparency
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - prisma/schema.prisma
  - src/lib/share/types.ts
  - src/stores/calculation-wizard-store.ts
  - src/components/calculations/overridable-value.tsx
autonomous: true

must_haves:
  truths:
    - "Overrides can be stored in the database per calculation"
    - "Override values replace calculated values when present"
    - "Overrides are typed and validated"
    - "OverridableValue component allows inline editing of any value"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "overrides Json? field on Calculation model"
      contains: "overrides"
    - path: "src/lib/share/types.ts"
      provides: "CalculationOverrides type definition"
      contains: "CalculationOverrides"
    - path: "src/stores/calculation-wizard-store.ts"
      provides: "Override state and setters in store"
      contains: "overrides"
    - path: "src/components/calculations/overridable-value.tsx"
      provides: "Inline edit component for override values"
      exports: ["OverridableValue"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "CalculationOverrides"
      via: "Json field stores this type"
      pattern: "overrides.*Json"
    - from: "calculation-wizard-store.ts"
      to: "CalculationOverrides"
      via: "store shape matches override type"
      pattern: "overrides:"
---

<objective>
Create the override infrastructure: database schema, types, store extension, and UI component for inline editing.

Purpose: OVRD-01 and OVRD-02 require salespersons to override calculation values. This plan creates the foundation - the schema field, types, store state, and the reusable inline-edit component.

Output: Schema with overrides field, CalculationOverrides type, extended wizard store, and OverridableValue component.
</objective>

<execution_context>
@/Users/julian.nordgren/.claude/get-shit-done/workflows/execute-plan.md
@/Users/julian.nordgren/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-calculation-transparency/07-RESEARCH.md

# Schema and store to extend
@prisma/schema.prisma
@src/stores/calculation-wizard-store.ts
@src/lib/share/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add override types and schema field</name>
  <files>
prisma/schema.prisma
src/lib/share/types.ts
  </files>
  <action>
Add override type definition and database schema field.

**In src/lib/share/types.ts**, add after CalculationBreakdownPublic:

```typescript
// =============================================================================
// MANUAL OVERRIDES (Admin only - never exposed to public)
// =============================================================================

/**
 * Manual overrides that salespeople can apply to calculations.
 * These values replace calculated values when present.
 *
 * IMPORTANT: Overrides are NEVER included in public types.
 * They are applied server-side before filtering to public data (OVRD-04).
 */
export interface CalculationOverrides {
  // Savings total overrides (OVRD-01)
  spotprisSavingsSek?: number | null      // null = use calculated
  stodtjansterIncomeSek?: number | null
  effectTariffSavingsSek?: number | null

  // Input overrides (OVRD-02)
  cyclesPerDay?: number | null
  peakShavingPercent?: number | null
  postCampaignRate?: number | null
  spreadOre?: number | null
  tariffRateSekKw?: number | null
}
```

**In prisma/schema.prisma**, find the Calculation model and add after the `results Json?` line:

```prisma
  // Manual overrides (Phase 7 - OVRD-01 to OVRD-04)
  // Salespeople can override calculated values; these are applied before public view
  overrides  Json?  // CalculationOverrides type - null means no overrides
```

Run `pnpm prisma format` to format the schema.
Do NOT run db push yet - that will happen after this plan completes.
  </action>
  <verify>
CalculationOverrides interface exists in src/lib/share/types.ts
prisma/schema.prisma contains overrides field on Calculation model
pnpm prisma format runs without errors
pnpm tsc --noEmit passes
  </verify>
  <done>
Override type defined in types.ts and schema field added to Calculation model.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend wizard store with override state</name>
  <files>src/stores/calculation-wizard-store.ts</files>
  <action>
Add override state and actions to the calculation wizard store.

Add to the store interface:

```typescript
// Override state (OVRD-01, OVRD-02)
overrides: {
  spotprisSavingsSek: number | null
  stodtjansterIncomeSek: number | null
  effectTariffSavingsSek: number | null
  cyclesPerDay: number | null
  peakShavingPercent: number | null
  postCampaignRate: number | null
  spreadOre: number | null
  tariffRateSekKw: number | null
}
setOverride: (key: keyof typeof initialState.overrides, value: number | null) => void
clearAllOverrides: () => void
hasAnyOverride: () => boolean
```

Add initial state:

```typescript
overrides: {
  spotprisSavingsSek: null,
  stodtjansterIncomeSek: null,
  effectTariffSavingsSek: null,
  cyclesPerDay: null,
  peakShavingPercent: null,
  postCampaignRate: null,
  spreadOre: null,
  tariffRateSekKw: null,
}
```

Add actions:

```typescript
setOverride: (key, value) => set((state) => ({
  overrides: { ...state.overrides, [key]: value }
})),

clearAllOverrides: () => set({
  overrides: {
    spotprisSavingsSek: null,
    stodtjansterIncomeSek: null,
    effectTariffSavingsSek: null,
    cyclesPerDay: null,
    peakShavingPercent: null,
    postCampaignRate: null,
    spreadOre: null,
    tariffRateSekKw: null,
  }
}),

hasAnyOverride: () => {
  const state = get()
  return Object.values(state.overrides).some(v => v !== null)
},
```

Include overrides in persist configuration (already using persist middleware).
  </action>
  <verify>
src/stores/calculation-wizard-store.ts has overrides state
setOverride, clearAllOverrides, hasAnyOverride actions exist
pnpm tsc --noEmit passes
  </verify>
  <done>
Wizard store extended with override state and actions for setting/clearing individual overrides.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OverridableValue component</name>
  <files>src/components/calculations/overridable-value.tsx</files>
  <action>
Create a reusable inline-edit component for override values.

Implementation:

```typescript
'use client'

import { useState, useRef, useEffect } from 'react'

interface OverridableValueProps {
  label?: string
  calculatedValue: number
  overrideValue: number | null
  onOverride: (value: number | null) => void
  formatFn?: (n: number) => string
  suffix?: string
  className?: string
}

export function OverridableValue({
  label,
  calculatedValue,
  overrideValue,
  onOverride,
  formatFn = (n) => Math.round(n).toLocaleString('sv-SE'),
  suffix = ' kr',
  className = '',
}: OverridableValueProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [inputValue, setInputValue] = useState('')
  const inputRef = useRef<HTMLInputElement>(null)

  const displayValue = overrideValue ?? calculatedValue
  const isOverridden = overrideValue !== null

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus()
      inputRef.current.select()
    }
  }, [isEditing])

  const handleSave = () => {
    const cleaned = inputValue.replace(/[^0-9.-]/g, '')
    const parsed = parseFloat(cleaned)
    if (!isNaN(parsed) && parsed >= 0) {
      onOverride(parsed)
    }
    setIsEditing(false)
  }

  const handleReset = () => {
    onOverride(null)
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSave()
    } else if (e.key === 'Escape') {
      setIsEditing(false)
    }
  }

  if (isEditing) {
    return (
      <div className={`inline-flex items-center gap-2 ${className}`}>
        {label && <span className="text-gray-600 dark:text-gray-400">{label}</span>}
        <input
          ref={inputRef}
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={handleSave}
          className="w-28 px-2 py-1 text-right border border-blue-500 rounded bg-white dark:bg-slate-800 text-gray-900 dark:text-gray-100"
          placeholder={formatFn(calculatedValue)}
        />
        <span className="text-gray-500 dark:text-gray-400">{suffix}</span>
      </div>
    )
  }

  return (
    <div className={`inline-flex items-center gap-2 group ${className}`}>
      {label && <span className="text-gray-600 dark:text-gray-400">{label}</span>}
      <span className={isOverridden ? 'text-blue-600 dark:text-blue-400 font-medium' : ''}>
        {formatFn(displayValue)}{suffix}
      </span>
      {isOverridden && (
        <span className="text-xs text-gray-400 dark:text-gray-500">
          (raknat: {formatFn(calculatedValue)})
        </span>
      )}
      <button
        onClick={() => {
          setInputValue(displayValue.toString())
          setIsEditing(true)
        }}
        className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-opacity"
        title="Andra varde manuellt"
        type="button"
      >
        <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
        </svg>
      </button>
      {isOverridden && (
        <button
          onClick={handleReset}
          className="opacity-0 group-hover:opacity-100 text-gray-400 hover:text-red-500 dark:hover:text-red-400 transition-opacity text-xs"
          title="Aterstall till beraknat varde"
          type="button"
        >
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
          </svg>
        </button>
      )}
    </div>
  )
}
```

Features:
- Shows calculated value by default
- Edit icon appears on hover
- Click to enter edit mode with input
- Enter to save, Escape to cancel
- Blue text when overridden with "calculated: X" shown in gray
- Reset button to clear override (return to calculated)
- Handles number parsing and validation
- Supports custom formatFn and suffix
  </action>
  <verify>
src/components/calculations/overridable-value.tsx exists
Exports OverridableValue component
pnpm tsc --noEmit passes
  </verify>
  <done>
OverridableValue component allows inline editing with visual indication of override status and reset capability.
  </done>
</task>

</tasks>

<verification>
1. pnpm tsc --noEmit passes
2. prisma/schema.prisma has overrides field
3. CalculationOverrides type matches schema field structure
4. Wizard store has override state with set/clear/check actions
5. OverridableValue component handles edit mode, save, reset
</verification>

<success_criteria>
- Database schema has overrides Json? field on Calculation model
- CalculationOverrides type defined with savings and input overrides
- Wizard store extended with overrides state and actions
- OverridableValue component allows inline editing with hover icons
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-calculation-transparency/07-03-SUMMARY.md`

IMPORTANT: After this plan completes, run `pnpm prisma db push` to apply schema changes before Plan 04.
</output>
