---
phase: 04-customer-experience
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/components/public/public-consumption-simulator.tsx
  - src/components/public/variant-indicator.tsx
  - src/components/public/sticky-results-bar.tsx
  - src/components/public/mobile-battery-carousel.tsx
  - src/app/(public)/[org]/[shareCode]/page.tsx
  - src/actions/share.ts
  - src/app/globals.css
autonomous: true

must_haves:
  truths:
    - "Prospect can adjust consumption hours via click-to-edit chart"
    - "Recalculation happens on 'Uppdatera' button click"
    - "Changed values highlighted vs original"
    - "Reset button restores original calculation"
    - "Variant saved when prospect makes changes"
    - "Mobile view has swipeable month tabs"
    - "Sticky bar shows key metrics while scrolling"
  artifacts:
    - path: "src/components/public/public-consumption-simulator.tsx"
      provides: "Interactive consumption editor for prospects"
      exports: ["PublicConsumptionSimulator"]
    - path: "src/components/public/sticky-results-bar.tsx"
      provides: "Floating metrics bar on scroll"
      exports: ["StickyResultsBar"]
    - path: "src/components/public/variant-indicator.tsx"
      provides: "Shows what prospect changed"
      exports: ["VariantIndicator"]
  key_links:
    - from: "src/components/public/public-consumption-simulator.tsx"
      to: "src/lib/calculations/engine.ts"
      via: "calculateBatteryROI import"
      pattern: "import.*calculateBatteryROI"
    - from: "src/app/(public)/[org]/[shareCode]/page.tsx"
      to: "src/components/public/public-consumption-simulator.tsx"
      via: "component integration"
      pattern: "PublicConsumptionSimulator"
---

<objective>
Add interactive consumption simulator to public view with on-demand recalculation, variant tracking, and mobile-optimized UI with sticky results bar.

Purpose: Prospects can adjust consumption and see how it affects their savings
Output: Interactive simulator, variant tracking, mobile experience with sticky bar
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-customer-experience/04-CONTEXT.md
@.planning/phases/04-customer-experience/04-02-SUMMARY.md
@.planning/phases/04-customer-experience/04-03-SUMMARY.md
@src/lib/calculations/engine.ts
@src/lib/calculations/types.ts
@src/components/calculations/wizard/consumption-simulator/day-chart.tsx
@src/components/calculations/wizard/consumption-simulator/month-tabs.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Public consumption simulator with on-demand recalculation</name>
  <files>src/components/public/public-consumption-simulator.tsx, src/components/public/variant-indicator.tsx</files>
  <action>
Create `src/components/public/public-consumption-simulator.tsx`:

```typescript
'use client'

import { useState, useMemo, useCallback } from 'react'
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
} from 'recharts'
import { calculateBatteryROI } from '@/lib/calculations/engine'
import type { CalculationResultsPublic, PublicBatteryInfo } from '@/lib/share/types'
import type { Elomrade } from '@prisma/client'
import { VariantIndicator } from './variant-indicator'

const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'Maj', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dec']
const HOURS = Array.from({ length: 24 }, (_, i) => i)

interface PublicConsumptionSimulatorProps {
  originalProfile: { data: number[][] }
  originalAnnualKwh: number
  originalResults: CalculationResultsPublic
  battery: PublicBatteryInfo
  natagare: {
    dayRateSekKw: number
    nightRateSekKw: number
    dayStartHour: number
    dayEndHour: number
  }
  elomrade: Elomrade
  quarterlyPrices: {
    avgDayPriceOre: number
    avgNightPriceOre: number
  }
  onResultsChange?: (results: CalculationResultsPublic, profile: number[][], annualKwh: number) => void
  primaryColor: string
}

export function PublicConsumptionSimulator({
  originalProfile,
  originalAnnualKwh,
  originalResults,
  battery,
  natagare,
  elomrade,
  quarterlyPrices,
  onResultsChange,
  primaryColor,
}: PublicConsumptionSimulatorProps) {
  // State
  const [profile, setProfile] = useState<number[][]>(() =>
    originalProfile.data.map(month => [...month])
  )
  const [selectedMonth, setSelectedMonth] = useState(0)
  const [results, setResults] = useState(originalResults)
  const [isDirty, setIsDirty] = useState(false)
  const [isRecalculating, setIsRecalculating] = useState(false)
  const [editingHour, setEditingHour] = useState<number | null>(null)
  const [editValue, setEditValue] = useState('')

  // Calculate annual consumption from profile
  const annualKwh = useMemo(() => {
    return profile.reduce((total, month) => {
      return total + month.reduce((sum, hour) => sum + hour, 0) * 30.44 // avg days per month
    }, 0)
  }, [profile])

  // Track which hours have changed
  const changedHours = useMemo(() => {
    const changes: Set<string> = new Set()
    profile.forEach((month, m) => {
      month.forEach((value, h) => {
        if (Math.abs(value - originalProfile.data[m][h]) > 0.01) {
          changes.add(`${m}-${h}`)
        }
      })
    })
    return changes
  }, [profile, originalProfile])

  const hasChanges = changedHours.size > 0

  // Handle hour click to edit
  const handleHourClick = (hour: number) => {
    setEditingHour(hour)
    setEditValue(profile[selectedMonth][hour].toFixed(2))
  }

  // Handle edit submit
  const handleEditSubmit = () => {
    if (editingHour === null) return
    const value = parseFloat(editValue)
    if (isNaN(value) || value < 0) return

    const newProfile = profile.map((month, m) =>
      m === selectedMonth
        ? month.map((v, h) => (h === editingHour ? value : v))
        : [...month]
    )
    setProfile(newProfile)
    setIsDirty(true)
    setEditingHour(null)
  }

  // Handle recalculation
  const handleRecalculate = useCallback(async () => {
    setIsRecalculating(true)

    // Small delay to show loading state
    await new Promise(resolve => setTimeout(resolve, 100))

    try {
      const { results: newResults } = calculateBatteryROI({
        battery: {
          capacityKwh: battery.capacityKwh,
          maxDischargeKw: battery.maxDischargeKw,
          maxChargeKw: battery.maxChargeKw,
          chargeEfficiency: battery.chargeEfficiency / 100,
          dischargeEfficiency: battery.dischargeEfficiency / 100,
          warrantyYears: battery.warrantyYears,
          guaranteedCycles: battery.guaranteedCycles,
          degradationPerYear: battery.degradationPerYear / 100,
        },
        pricing: {
          totalPriceExVat: battery.totalPriceExVat,
          installationCost: 0, // Not shown to prospect
        },
        consumption: {
          annualKwh,
          profile: { data: profile },
        },
        location: {
          elomrade,
        },
        natagare: {
          dayRateSekKw: natagare.dayRateSekKw,
          nightRateSekKw: natagare.nightRateSekKw,
          dayStartHour: natagare.dayStartHour,
          dayEndHour: natagare.dayEndHour,
        },
        electricityPrices: {
          avgDayPriceOre: quarterlyPrices.avgDayPriceOre,
          avgNightPriceOre: quarterlyPrices.avgNightPriceOre,
        },
      })

      const publicResults: CalculationResultsPublic = {
        totalPriceExVat: newResults.totalPriceExVat,
        totalPriceIncVat: newResults.totalPriceIncVat,
        costAfterGronTeknik: newResults.costAfterGronTeknik,
        effectiveCapacityKwh: newResults.effectiveCapacityKwh,
        annualEnergyKwh: newResults.annualEnergyKwh,
        spotprisSavings: newResults.spotprisSavings,
        effectTariffSavings: newResults.effectTariffSavings,
        gridServicesIncome: newResults.gridServicesIncome,
        totalAnnualSavings: newResults.totalAnnualSavings,
        paybackYears: newResults.paybackYears,
        roi10Year: newResults.roi10Year,
        roi15Year: newResults.roi15Year,
      }

      setResults(publicResults)
      setIsDirty(false)
      onResultsChange?.(publicResults, profile, annualKwh)
    } catch (error) {
      console.error('Recalculation failed:', error)
    }

    setIsRecalculating(false)
  }, [profile, annualKwh, battery, natagare, elomrade, quarterlyPrices, onResultsChange])

  // Reset to original
  const handleReset = () => {
    setProfile(originalProfile.data.map(month => [...month]))
    setResults(originalResults)
    setIsDirty(false)
  }

  // Chart data for selected month
  const chartData = HOURS.map(hour => ({
    hour: hour.toString().padStart(2, '0'),
    value: profile[selectedMonth][hour],
    isChanged: changedHours.has(`${selectedMonth}-${hour}`),
    isNight: hour < natagare.dayStartHour || hour >= natagare.dayEndHour,
  }))

  return (
    <section className="bg-white rounded-lg shadow-sm overflow-hidden">
      <div className="p-6 border-b">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              Din förbrukning
            </h3>
            <p className="text-sm text-gray-500 mt-1">
              Klicka på en stapel för att justera din förbrukning och se hur det påverkar din besparing.
            </p>
          </div>
          {hasChanges && (
            <VariantIndicator
              changedCount={changedHours.size}
              onReset={handleReset}
            />
          )}
        </div>
      </div>

      {/* Month tabs - swipeable on mobile */}
      <div className="border-b overflow-x-auto scrollbar-hide">
        <div className="flex px-4 py-2 gap-1 min-w-max">
          {MONTHS.map((month, index) => (
            <button
              key={month}
              onClick={() => setSelectedMonth(index)}
              className={`px-3 py-2 rounded-md text-sm font-medium whitespace-nowrap transition-colors ${
                selectedMonth === index
                  ? 'text-white'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
              style={
                selectedMonth === index
                  ? { backgroundColor: primaryColor }
                  : undefined
              }
            >
              {month}
            </button>
          ))}
        </div>
      </div>

      {/* Chart */}
      <div className="p-4">
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={chartData}>
              <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" />
              <XAxis
                dataKey="hour"
                tick={{ fontSize: 10 }}
                interval={2}
              />
              <YAxis
                tick={{ fontSize: 10 }}
                tickFormatter={(v) => `${v.toFixed(1)}`}
                label={{
                  value: 'kWh',
                  angle: -90,
                  position: 'insideLeft',
                  fontSize: 10,
                }}
              />
              <Tooltip
                formatter={(value: number) => [`${value.toFixed(2)} kWh`, 'Förbrukning']}
                labelFormatter={(label) => `Kl ${label}:00`}
              />
              <Bar
                dataKey="value"
                onClick={(_, index) => handleHourClick(index)}
                cursor="pointer"
              >
                {chartData.map((entry, index) => (
                  <Cell
                    key={`cell-${index}`}
                    fill={
                      entry.isChanged
                        ? '#F59E0B' // Changed: orange
                        : entry.isNight
                        ? '#6366F1' // Night: indigo
                        : primaryColor // Day: brand color
                    }
                  />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>

        {/* Legend */}
        <div className="flex flex-wrap gap-4 mt-4 text-xs text-gray-500">
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 rounded" style={{ backgroundColor: primaryColor }} />
            <span>Dagförbrukning</span>
          </div>
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 rounded bg-indigo-500" />
            <span>Nattförbrukning</span>
          </div>
          {hasChanges && (
            <div className="flex items-center gap-1">
              <div className="w-3 h-3 rounded bg-amber-500" />
              <span>Ändrad</span>
            </div>
          )}
        </div>
      </div>

      {/* Edit modal */}
      {editingHour !== null && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-sm w-full mx-4">
            <h4 className="text-lg font-medium mb-4">
              Ändra förbrukning kl {editingHour.toString().padStart(2, '0')}:00
            </h4>
            <div className="flex gap-2">
              <input
                type="number"
                value={editValue}
                onChange={(e) => setEditValue(e.target.value)}
                step="0.1"
                min="0"
                className="flex-1 px-3 py-2 border rounded-md"
                autoFocus
                onKeyDown={(e) => e.key === 'Enter' && handleEditSubmit()}
              />
              <span className="self-center text-gray-500">kWh</span>
            </div>
            <div className="flex gap-2 mt-4">
              <button
                onClick={() => setEditingHour(null)}
                className="flex-1 px-4 py-2 border rounded-md hover:bg-gray-50"
              >
                Avbryt
              </button>
              <button
                onClick={handleEditSubmit}
                className="flex-1 px-4 py-2 text-white rounded-md"
                style={{ backgroundColor: primaryColor }}
              >
                Spara
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Update button */}
      <div className="p-4 bg-gray-50 border-t">
        <div className="flex items-center justify-between">
          <div className="text-sm text-gray-600">
            Årsförbrukning: <span className="font-medium">{Math.round(annualKwh).toLocaleString('sv-SE')} kWh</span>
            {annualKwh !== originalAnnualKwh && (
              <span className="text-amber-600 ml-2">
                ({annualKwh > originalAnnualKwh ? '+' : ''}
                {Math.round(annualKwh - originalAnnualKwh).toLocaleString('sv-SE')})
              </span>
            )}
          </div>
          <button
            onClick={handleRecalculate}
            disabled={!isDirty || isRecalculating}
            className={`px-6 py-2 rounded-md font-medium transition-colors ${
              isDirty
                ? 'text-white hover:opacity-90'
                : 'bg-gray-200 text-gray-500 cursor-not-allowed'
            }`}
            style={isDirty ? { backgroundColor: primaryColor } : undefined}
          >
            {isRecalculating ? 'Räknar...' : 'Uppdatera'}
          </button>
        </div>
      </div>
    </section>
  )
}
```

Create `src/components/public/variant-indicator.tsx`:

```typescript
interface VariantIndicatorProps {
  changedCount: number
  onReset: () => void
}

export function VariantIndicator({ changedCount, onReset }: VariantIndicatorProps) {
  return (
    <div className="flex items-center gap-3 bg-amber-50 border border-amber-200 rounded-md px-3 py-2">
      <div className="flex items-center gap-2 text-sm text-amber-700">
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          />
        </svg>
        <span>
          {changedCount} {changedCount === 1 ? 'timme ändrad' : 'timmar ändrade'}
        </span>
      </div>
      <button
        onClick={onReset}
        className="text-sm text-amber-700 hover:text-amber-900 underline"
      >
        Visa ursprunglig
      </button>
    </div>
  )
}
```
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>PublicConsumptionSimulator with click-to-edit bars, on-demand recalculation, change tracking, and reset functionality</done>
</task>

<task type="auto">
  <name>Task 2: Sticky results bar and mobile optimizations</name>
  <files>src/components/public/sticky-results-bar.tsx, src/components/public/mobile-battery-carousel.tsx, src/app/globals.css</files>
  <action>
Create `src/components/public/sticky-results-bar.tsx`:

```typescript
'use client'

import { useEffect, useState } from 'react'
import type { CalculationResultsPublic } from '@/lib/share/types'

interface StickyResultsBarProps {
  results: CalculationResultsPublic
  primaryColor: string
  showThreshold?: number // pixels scrolled before showing
}

function formatSek(value: number): string {
  return new Intl.NumberFormat('sv-SE', {
    style: 'currency',
    currency: 'SEK',
    maximumFractionDigits: 0,
  }).format(value)
}

export function StickyResultsBar({
  results,
  primaryColor,
  showThreshold = 400,
}: StickyResultsBarProps) {
  const [isVisible, setIsVisible] = useState(false)

  useEffect(() => {
    const handleScroll = () => {
      setIsVisible(window.scrollY > showThreshold)
    }

    window.addEventListener('scroll', handleScroll, { passive: true })
    return () => window.removeEventListener('scroll', handleScroll)
  }, [showThreshold])

  return (
    <div
      className={`fixed bottom-0 left-0 right-0 bg-white border-t shadow-lg z-40 transition-transform duration-300 ${
        isVisible ? 'translate-y-0' : 'translate-y-full'
      }`}
    >
      <div className="max-w-4xl mx-auto px-4 py-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-6">
            <div>
              <p className="text-xs text-gray-500">Återbetalningstid</p>
              <p
                className="text-lg font-bold"
                style={{ color: primaryColor }}
              >
                {results.paybackYears.toFixed(1)} år
              </p>
            </div>
            <div className="hidden sm:block">
              <p className="text-xs text-gray-500">Årlig besparing</p>
              <p className="text-lg font-bold text-gray-900">
                {formatSek(results.totalAnnualSavings)}
              </p>
            </div>
          </div>
          <a
            href="#kontakt"
            className="px-4 py-2 rounded-md text-white text-sm font-medium"
            style={{ backgroundColor: primaryColor }}
          >
            Kontakta mig
          </a>
        </div>
      </div>
    </div>
  )
}
```

Create `src/components/public/mobile-battery-carousel.tsx`:

```typescript
'use client'

import { useState, useRef, useEffect } from 'react'
import type { PublicBatteryInfo, CalculationResultsPublic } from '@/lib/share/types'

interface MobileBatteryCarouselProps {
  batteries: PublicBatteryInfo[]
  results: CalculationResultsPublic
  onSelect: (index: number) => void
  selectedIndex: number
  primaryColor: string
}

function formatSek(value: number): string {
  return new Intl.NumberFormat('sv-SE', {
    style: 'currency',
    currency: 'SEK',
    maximumFractionDigits: 0,
  }).format(value)
}

export function MobileBatteryCarousel({
  batteries,
  results,
  onSelect,
  selectedIndex,
  primaryColor,
}: MobileBatteryCarouselProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const [touchStart, setTouchStart] = useState<number | null>(null)

  // Scroll to selected item
  useEffect(() => {
    const container = containerRef.current
    if (!container) return
    const card = container.children[selectedIndex] as HTMLElement
    if (card) {
      card.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' })
    }
  }, [selectedIndex])

  // Handle swipe
  const handleTouchStart = (e: React.TouchEvent) => {
    setTouchStart(e.touches[0].clientX)
  }

  const handleTouchEnd = (e: React.TouchEvent) => {
    if (touchStart === null) return
    const touchEnd = e.changedTouches[0].clientX
    const diff = touchStart - touchEnd

    if (Math.abs(diff) > 50) {
      if (diff > 0 && selectedIndex < batteries.length - 1) {
        onSelect(selectedIndex + 1)
      } else if (diff < 0 && selectedIndex > 0) {
        onSelect(selectedIndex - 1)
      }
    }
    setTouchStart(null)
  }

  return (
    <div className="lg:hidden">
      {/* Carousel */}
      <div
        ref={containerRef}
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
        className="flex overflow-x-auto snap-x snap-mandatory gap-4 px-4 pb-4 scrollbar-hide"
      >
        {batteries.map((battery, index) => (
          <div
            key={index}
            onClick={() => onSelect(index)}
            className={`snap-center flex-shrink-0 w-72 bg-white rounded-lg border-2 p-4 cursor-pointer transition-all ${
              selectedIndex === index
                ? 'shadow-md'
                : 'border-gray-200 opacity-80'
            }`}
            style={
              selectedIndex === index
                ? { borderColor: primaryColor }
                : undefined
            }
          >
            <div className="flex items-center gap-3 mb-3">
              {battery.brandLogoUrl && (
                <img
                  src={battery.brandLogoUrl}
                  alt={battery.brandName}
                  className="h-8 w-auto object-contain"
                />
              )}
              <div>
                <p className="font-medium text-gray-900">{battery.name}</p>
                <p className="text-sm text-gray-500">{battery.capacityKwh} kWh</p>
              </div>
            </div>
            <div className="grid grid-cols-2 gap-2 text-sm">
              <div>
                <p className="text-gray-500">Återbetalningstid</p>
                <p className="font-bold" style={{ color: primaryColor }}>
                  {results.paybackYears.toFixed(1)} år
                </p>
              </div>
              <div>
                <p className="text-gray-500">Årlig besparing</p>
                <p className="font-bold text-gray-900">
                  {formatSek(results.totalAnnualSavings)}
                </p>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Dots indicator */}
      {batteries.length > 1 && (
        <div className="flex justify-center gap-2 mt-2">
          {batteries.map((_, index) => (
            <button
              key={index}
              onClick={() => onSelect(index)}
              className={`w-2 h-2 rounded-full transition-colors ${
                selectedIndex === index ? '' : 'bg-gray-300'
              }`}
              style={
                selectedIndex === index
                  ? { backgroundColor: primaryColor }
                  : undefined
              }
              aria-label={`Visa batteri ${index + 1}`}
            />
          ))}
        </div>
      )}
    </div>
  )
}
```

Add scrollbar-hide utility to `src/app/globals.css`:

```css
/* Add to existing globals.css */

/* Hide scrollbar but allow scrolling */
.scrollbar-hide {
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
}
.scrollbar-hide::-webkit-scrollbar {
  display: none;  /* Chrome, Safari and Opera */
}

/* Animations for modal/overlay */
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slide-up {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.animate-fade-in {
  animation: fade-in 0.15s ease-out;
}

.animate-slide-up {
  animation: slide-up 0.2s ease-out;
}
```
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>StickyResultsBar with scroll-triggered visibility, MobileBatteryCarousel with swipe gestures and dot indicators</done>
</task>

<task type="auto">
  <name>Task 3: Integrate simulator and mobile components into public view</name>
  <files>src/app/(public)/[org]/[shareCode]/page.tsx, src/actions/share.ts</files>
  <action>
Update `src/app/(public)/[org]/[shareCode]/page.tsx` to include:

1. Import new components:
```typescript
import { PublicConsumptionSimulator } from '@/components/public/public-consumption-simulator'
import { StickyResultsBar } from '@/components/public/sticky-results-bar'
import { MobileBatteryCarousel } from '@/components/public/mobile-battery-carousel'
```

2. Add quarterly prices to the data fetching (needed for recalculation):
```typescript
// Add to the page component, fetch quarterly prices for the calculation's elomrade
import { prisma } from '@/lib/db/client'

// Inside the page component, after getting calculation data:
const currentQuarter = Math.ceil((new Date().getMonth() + 1) / 3)
const quarterlyPrices = await prisma.electricityPriceQuarterly.findFirst({
  where: {
    elomrade: result.data.calculation.elomrade,
    year: new Date().getFullYear(),
    quarter: currentQuarter,
  },
  select: {
    avgDayPriceOre: true,
    avgNightPriceOre: true,
  },
})
```

3. Add client-side wrapper for interactive state:
```typescript
// Create a client component wrapper for the interactive parts
'use client'

import { useState } from 'react'

// In the page JSX, wrap with client component that manages results state:
function InteractivePublicView({ /* props */ }) {
  const [currentResults, setCurrentResults] = useState(results)
  const [selectedBatteryIndex, setSelectedBatteryIndex] = useState(0)

  const handleResultsChange = (newResults, newProfile, newAnnualKwh) => {
    setCurrentResults(newResults)
    // Optionally save variant via server action
    saveVariant(calculationId, newProfile, newAnnualKwh, newResults)
  }

  return (
    <>
      {/* Mobile battery carousel (hidden on desktop) */}
      {batteries.length > 1 && (
        <MobileBatteryCarousel
          batteries={batteries}
          results={currentResults}
          selectedIndex={selectedBatteryIndex}
          onSelect={setSelectedBatteryIndex}
          primaryColor={organization.primaryColor}
        />
      )}

      {/* Consumption simulator */}
      <PublicConsumptionSimulator
        originalProfile={consumptionProfile}
        originalAnnualKwh={annualConsumptionKwh}
        originalResults={results}
        battery={batteries[selectedBatteryIndex]}
        natagare={natagare}
        elomrade={elomrade}
        quarterlyPrices={quarterlyPrices}
        onResultsChange={handleResultsChange}
        primaryColor={organization.primaryColor}
      />

      {/* Battery summary with current results */}
      <PublicBatterySummary
        battery={batteries[selectedBatteryIndex]}
        allBatteries={batteries}
        results={currentResults}
      />

      {/* Results view with current results */}
      <PublicResultsView
        results={currentResults}
        primaryColor={organization.primaryColor}
      />

      {/* Sticky bar */}
      <StickyResultsBar
        results={currentResults}
        primaryColor={organization.primaryColor}
      />
    </>
  )
}
```

4. Split into server and client components properly:
- Keep data fetching in server component
- Pass data to client wrapper for interactivity

---

Add variant saving to `src/actions/share.ts`:

```typescript
// Add to share.ts

export async function saveVariant(
  calculationId: string,
  consumptionProfile: number[][],
  annualConsumptionKwh: number,
  results: CalculationResultsPublic
): Promise<{ id?: string; error?: string }> {
  try {
    const variant = await prisma.calculationVariant.create({
      data: {
        calculationId,
        consumptionProfile: { data: consumptionProfile },
        annualConsumptionKwh,
        results: results as unknown as Prisma.InputJsonValue,
      },
    })
    return { id: variant.id }
  } catch (error) {
    console.error('Failed to save variant:', error)
    return { error: 'Kunde inte spara varianten' }
  }
}
```

The key integration points:
- Server component fetches data and quarterly prices
- Client component manages interactive state
- Results update locally after recalculation
- Variants saved to database for tracking
- Sticky bar shows current results
- Mobile carousel for battery selection
  </action>
  <verify>npx tsc --noEmit && npm run build</verify>
  <done>Public view integrated with interactive simulator, mobile carousel, sticky bar, and variant saving</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm run build` - Build succeeds
3. Test: Click hour in chart opens edit modal
4. Test: Change value and click "Uppdatera" recalculates
5. Test: "Visa ursprunglig" resets to original
6. Test: Scroll down shows sticky bar
7. Test on mobile: Swipe month tabs
8. Test on mobile: Swipe battery carousel
</verification>

<success_criteria>
- Click-to-edit bars work with modal input
- "Uppdatera" button triggers recalculation
- Changed hours highlighted in orange
- VariantIndicator shows change count
- "Visa ursprunglig" button resets everything
- Annual kWh updates with changes
- Results update after recalculation
- Variant saved to database
- Sticky bar appears after scrolling past threshold
- Mobile battery carousel swipeable
- Month tabs horizontally scrollable on mobile
- All animations smooth (fade-in, slide-up)
</success_criteria>

<output>
After completion, create `.planning/phases/04-customer-experience/04-04-SUMMARY.md`
</output>
